<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="referrer" content="no-referrer">
    <title>XXL-JOB任务调度源码分析</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        body {
            font-family: 'PingFang SC', Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #F7F9FC;
            color: #333;
            line-height: 1.6;
            overflow-x: hidden;
        }
        .top-bar {
            background: linear-gradient(135deg, #7B68EE, #4A90E2);
            padding: 15px 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            position: fixed;
            width: 100%;
            top: 0;
            z-index: 1000;
            box-sizing: border-box;
        }
        .top-bar h1 {
            margin: 0;
            font-size: 1.8em;
            color: white;
        }
        nav {
            background-color: #FFFFFF;
            padding: 15px 0;
            position: fixed;
            top: 60px;
            width: 100%;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
            z-index: 999;
            box-sizing: border-box;
        }
        nav ul {
            list-style-type: none;
            padding: 0;
            display: flex;
            justify-content: center;
            margin: 0;
        }
        nav li {
            position: relative;
            margin: 0 20px;
        }
        nav a {
            text-decoration: none;
            color: #4A90E2;
            font-weight: bold;
            padding: 10px 15px;
            display: flex;
            align-items: center;
            transition: color 0.3s;
        }
        nav a:hover {
            color: #F5A623;
        }
        nav i {
            margin-right: 8px;
        }
        nav .dropdown {
            display: none;
            position: absolute;
            background-color: #FFFFFF;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            min-width: 150px;
            top: 100%;
            left: 0;
            border-radius: 8px;
        }
        nav li:hover .dropdown {
            display: block;
        }
        nav .dropdown a {
            padding: 10px;
            color: #4A90E2;
            font-weight: normal;
        }
        nav .dropdown a:hover {
            background-color: #E9F1FF;
            color: #F5A623;
        }
        .container {
            max-width: 1500px;
            margin: 120px auto 20px;
            display: flex;
            gap: 30px;
            padding: 0 20px;
            box-sizing: border-box;
        }
        main {
            flex: 2;
            max-width: 100%;
        }
        aside {
            width: 350px;
            flex-shrink: 0;
            max-width: 100%;
        }
        .section {
            background-color: #FFFFFF;
            padding: 25px;
            margin-bottom: 20px;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
            margin-top: 40px;
            box-sizing: border-box;
        }
        .section h1 {
            color: #4A90E2;
            font-size: 2.5em;
            margin: 0 0 15px;
            word-wrap: break-word;
        }
        .section h2 {
            color: #4A90E2;
            font-size: 1.8em;
            margin: 25px 0 15px;
            word-wrap: break-word;
        }
        .section h3 {
            color: #333;
            font-size: 1.2em;
            margin: 20px 0 10px;
            word-wrap: break-word;
        }
        .article-meta {
            font-size: 0.9em;
            color: #666;
            margin: 10px 0;
        }
        .article-content p {
            margin: 15px 0;
            word-wrap: break-word;
        }
        .article-content pre {
            background-color: #2D2D2D;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Consolas', 'Courier New', monospace;
            font-size: 0.95em;
            color: #ABB2BF;
            border: 1px solid #404040;
            white-space: pre-wrap;
            word-break: break-word;
            max-width: 100%;
            box-sizing: border-box;
        }
        .article-content pre code {
            display: block;
        }
        .article-content pre.java span.keyword {
            color: #E5C07B;
        }
        .article-content pre.java span.string {
            color: #98C379;
        }
        .article-content pre.java span.comment {
            color: #5C6370;
        }
        .article-content code {
            background-color: #333;
            color: #E9ECEF;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Consolas', 'Courier New', monospace;
            word-wrap: break-word;
        }
        .article-content blockquote {
            background-color: #F5F6F5;
            border-left: 4px solid #4A90E2;
            padding: 10px 15px;
            margin: 15px 0;
            color: #555;
            border-radius: 4px;
            word-wrap: break-word;
            font-size: 0.95em;
            font-style: italic;
        }
        .article-content img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 15px 0;
            border-radius: 8px;
        }
        .article-content ol {
            padding-left: 20px;
        }
        .article-content ol ol {
            list-style-type: lower-alpha;
        }
        .article-content ol ol ol {
            list-style-type: lower-roman;
        }
        .article-content ol ol ol ol {
            list-stylePennState: decimal;
        }
        .article-content ol ol ol ol ol {
            list-style-type: lower-alpha;
        }
        .article-tags {
            margin: 20px 0;
        }
        .article-tags a {
            display: inline-block;
            padding: 5px 10px;
            margin-right: 5px;
            background-color: #E9F1FF;
            color: #4A90E2;
            border-radius: 12px;
            text-decoration: none;
            font-size: 0.85em;
        }
        aside .section {
            padding: 20px;
            box-sizing: border-box;
        }
        aside ul {
            list-style-type: none;
            padding: 0;
        }
        aside li {
            margin: 10px 0;
        }
        aside .toc ul ul {
            margin-left: 20px;
        }
        aside .toc ul ul ul {
            margin-left: 40px;
        }
        aside a {
            color: #4A90E2;
            text-decoration: none;
            transition: color 0.3s;
            word-wrap: break-word;
        }
        aside a:hover {
            color: #F5A623;
        }
        .toc h3, .tags h3, .hot-posts h3 {
            color: #4A90E2;
            font-size: 1.6em;
            margin: 0 0 15px;
        }
        footer {
            background: linear-gradient(135deg, #7B68EE, #4A90E2);
            color: white;
            padding: 30px;
            text-align: center;
            border-radius: 15px 15px 0 0;
            margin-top: 20px;
            box-sizing: border-box;
            width: 100%;
        }
        footer .social a {
            color: #F5A623;
            margin: 0 10px;
            font-size: 1.5em;
            transition: color 0.3s;
        }
        footer .social a:hover {
            color: #FF7F50;
        }
    </style>
</head>
<body>
<div class="top-bar">
    <h1>Java技术站</h1>
</div>
<nav>
    <ul>
        <li><a href="#"><i class="fas fa-code"></i> 核心Java</a></li>
        <li><a href="#"><i class="fas fa-leaf"></i> Spring框架</a>
            <div class="dropdown">
                <a href="#">Spring Boot</a>
                <a href="#">Spring Security</a>
            </div>
        </li>
        <li><a href="#"><i class="fas fa-database"></i> 持久化技术</a></li>
        <li><a href="#"><i class="fas fa-tools"></i> 构建工具</a></li>
        <li><a href="#"><i class="fas fa-cloud"></i> 微服务与云</a></li>
        <li><a href="#"><i class="fas fa-file"></i> 源码研究</a>
            <div class="dropdown">
                <a href="#">XXL-JOB</a>
            </div>
        </li>
        <li><a href="online-issues-index.html"><i class="fas fa-bug"></i> 线上问题记录</a></li>
    </ul>
</nav>
<div class="container">
    <main>
        <section class="section article-content">
            <h1>XXL-JOB任务调度源码分析</h1>
            <div class="article-meta">发布于：2025-04-11</div>
            <p>上一篇我们介绍了 <a href="20250411161955.html" target="_blank"> XXL-JOB原理及任务注册与心跳源码分析</a> 。这篇文章介绍XXL-JOB是如何进行任务调度的</p>
            <h2 id="section-2">任务调度</h2>

            <h3 id="section-2-a">a. 整体调度流程概述</h3>
            <p>XXL-JOB 的调度主要分为调度中心和执行器两部分。调度中心负责任务的管理、调度触发；执行器负责接收调度中心的任务请求并执行具体的任务。整体流程如下：</p>
            <ol>
                <li>调度中心根据任务的配置（如 Cron 表达式）计算任务的下次执行时间。</li>
                <li>到达任务执行时间时，调度中心向对应的执行器发送调度请求。</li>
                <li>执行器接收到调度请求后，执行具体的任务逻辑。</li>
                <li>执行器将任务执行结果反馈给调度中心。</li>
            </ol>

            <h3 id="section-2-b">b. 源码分析</h3>

            <h4 id="section-2-b-i">ⅰ. 调度中心的任务调度</h4>
            <p>在调度中心启动时，会初始化任务调度相关的组件，初始化组件是在 <code>XxlJobScheduler</code> 类中的 <code>init()</code> 方法。而任务调度主要在 <code>JobScheduleHelper</code> 类的 <code>start</code> 方法中完成：</p>
            <p><strong>方法逻辑</strong>：主要是负责启动两个线程：<code>scheduleThread</code> 和 <code>ringThread</code>，用于处理定时任务的调度和触发。</p>
            <p>这里去掉了部分代码，只保留主要逻辑</p>
            <pre class="java"><code>
<span class="keyword">public</span> <span class="keyword">void</span> start() {

    <span class="comment">// schedule 线程的作用</span>
    <span class="comment">// 1. 初始化调度器：线程启动后，首先会等待直到当前时间的毫秒数为0，然后输出初始化成功的日志</span>
    <span class="comment">// 2. 预读取任务：计算预读取任务的数量，这个数量基于触发器线程池的大小和QPS（每秒查询率）。</span>
    scheduleThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
        @Override
        <span class="keyword">public</span> <span class="keyword">void</span> run() {

            <span class="comment">// pre-read count: treadpool-size * trigger-qps (each trigger cost 50ms, qps = 1000/50 = 20)</span>
            <span class="keyword">int</span> preReadCount = (XxlJobAdminConfig.getAdminConfig().getTriggerPoolFastMax() + XxlJobAdminConfig.getAdminConfig().getTriggerPoolSlowMax()) * 20;

            <span class="keyword">while</span> (!scheduleThreadToStop) {

                Connection conn = <span class="keyword">null</span>;
                Boolean connAutoCommit = <span class="keyword">null</span>;
                PreparedStatement preparedStatement = <span class="keyword">null</span>;

                <span class="keyword">boolean</span> preReadSuc = <span class="keyword">true</span>;
                <span class="keyword">try</span> {

                    <span class="comment">// 获取数据库连接，并设置为手动提交事务。</span>
                    conn = XxlJobAdminConfig.getAdminConfig().getDataSource().getConnection();
                    connAutoCommit = conn.getAutoCommit();
                    conn.setAutoCommit(<span class="keyword">false</span>);

                    <span class="comment">// 尝试获取调度锁，以确保同一时间只有一个线程在执行调度任务</span>
                    preparedStatement = conn.prepareStatement(<span class="string">"select * from xxl_job_lock where lock_name = 'schedule_lock' for update"</span>);
                    preparedStatement.execute();

                    <span class="comment">// tx start</span>

                    <span class="comment">// 1、pre read</span>
                    <span class="keyword">long</span> nowTime = System.currentTimeMillis();
                    List&lt;XxlJobInfo&gt; scheduleList = XxlJobAdminConfig.getAdminConfig().getXxlJobInfoDao().scheduleJobQuery(nowTime + PRE_READ_MS, preReadCount);
                    <span class="keyword">if</span> (scheduleList != <span class="keyword">null</span> && scheduleList.size() > 0) {
                        <span class="comment">// 2、push time-ring</span>
                        <span class="keyword">for</span> (XxlJobInfo jobInfo : scheduleList) {

                            <span class="comment">// time-ring jump</span>
                            <span class="keyword">if</span> (nowTime > jobInfo.getTriggerNextTime() + PRE_READ_MS) {

                                <span class="comment">// 刷新下一个任务的时间</span>
                                refreshNextValidTime(jobInfo, <span class="keyword">new</span> Date());

                            } <span class="keyword">else</span> <span class="keyword">if</span> (nowTime > jobInfo.getTriggerNextTime()) {
                                <span class="comment">// 当前时间大于任务的下一个触发时间，但未超过预设的提前读取时间</span>

                                <span class="comment">// 触发任务</span>
                                JobTriggerPoolHelper.trigger(jobInfo.getId(), TriggerTypeEnum.CRON, -1, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);

                                <span class="comment">// 刷新下一个任务的时间</span>
                                refreshNextValidTime(jobInfo, <span class="keyword">new</span> Date());

                                <span class="comment">// 检查是否需要在5秒内再次预读</span>
                                <span class="keyword">if</span> (jobInfo.getTriggerStatus() == 1 && nowTime + PRE_READ_MS > jobInfo.getTriggerNextTime()) {

                                    <span class="comment">// 1、计算秒</span>
                                    <span class="keyword">int</span> ringSecond = (<span class="keyword">int</span>) ((jobInfo.getTriggerNextTime() / 1000) % 60);

                                    <span class="comment">// 2、推送时间环</span>
                                    pushTimeRing(ringSecond, jobInfo.getId());

                                    <span class="comment">// 3、刷新下一个任务的时间</span>
                                    refreshNextValidTime(jobInfo, <span class="keyword">new</span> Date(jobInfo.getTriggerNextTime()));

                                }

                            } <span class="keyword">else</span> {
                                <span class="comment">// 如果当前时间还未到达任务的下一个触发时间。</span>

                                <span class="comment">// 1、计算环秒数</span>
                                <span class="keyword">int</span> ringSecond = (<span class="keyword">int</span>) ((jobInfo.getTriggerNextTime() / 1000) % 60);

                                <span class="comment">// 2、推送时间环。</span>
                                pushTimeRing(ringSecond, jobInfo.getId());

                                <span class="comment">// 3、刷新下一个任务的时间</span>
                                refreshNextValidTime(jobInfo, <span class="keyword">new</span> Date(jobInfo.getTriggerNextTime()));

                            }

                        }

                        <span class="comment">// 3、更新调度列表中的触发器信息</span>
                        <span class="keyword">for</span> (XxlJobInfo jobInfo : scheduleList) {
                            XxlJobAdminConfig.getAdminConfig().getXxlJobInfoDao().scheduleUpdate(jobInfo);
                        }

                    } <span class="keyword">else</span> {
                        preReadSuc = <span class="keyword">false</span>;
                    }

                    <span class="comment">// tx stop</span>

                } <span class="keyword">catch</span> (Exception e) {
                    <span class="keyword">if</span> (!scheduleThreadToStop) {
                        logger.error(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, JobScheduleHelper#scheduleThread error:{}"</span>, e);
                    }
                } <span class="keyword">finally</span> {

                    <span class="comment">// commit</span>

                }

            }
        });
        scheduleThread.setDaemon(<span class="keyword">true</span>);
        scheduleThread.setName(<span class="string">"xxl-job, admin JobScheduleHelper#scheduleThread"</span>);
        scheduleThread.start();

        <span class="comment">// 初始化时间环：线程启动后，首先会等待直到当前时间的毫秒数为0。</span>
        ringThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {
            @Override
            <span class="keyword">public</span> <span class="keyword">void</span> run() {

                <span class="keyword">while</span> (!ringThreadToStop) {

                    <span class="keyword">try</span> {
                        <span class="comment">// second data</span>
                        List&lt;Integer&gt; ringItemData = <span class="keyword">new</span> ArrayList&lt;&gt;();
                        <span class="comment">// 避免处理耗时太长，跨过刻度，向前校验一个刻度；</span>
                        <span class="keyword">int</span> nowSecond = Calendar.getInstance().get(Calendar.SECOND);
                        <span class="keyword">for</span> (<span class="keyword">int</span> i = 0; i < 2; i++) {
                            <span class="comment">// 从ringData中移除并获取当前秒和前一秒的任务列表。</span>
                            List&lt;Integer&gt; tmpData = ringData.remove((nowSecond + 60 - i) % 60);
                            <span class="keyword">if</span> (tmpData != <span class="keyword">null</span>) {
                                ringItemData.addAll(tmpData);
                            }
                        }

                        <span class="keyword">if</span> (ringItemData.size() > 0) {
                            <span class="comment">// 如果ringItemData中有任务ID，表示有任务需要触发。</span>
                            <span class="keyword">for</span> (<span class="keyword">int</span> jobId : ringItemData) {
                                <span class="comment">// 触发任务</span>
                                JobTriggerPoolHelper.trigger(jobId, TriggerTypeEnum.CRON, -1, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);
                            }
                            <span class="comment">// clear</span>
                            ringItemData.clear();
                        }
                    } <span class="keyword">catch</span> (Exception e) {
                        <span class="keyword">if</span> (!ringThreadToStop) {
                            logger.error(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, JobScheduleHelper#ringThread error:{}"</span>, e);
                        }
                    }

                    <span class="comment">// 再次对齐秒数，准备进入下一个循环。</span>
                    <span class="keyword">try</span> {
                        TimeUnit.MILLISECONDS.sleep(1000 - System.currentTimeMillis() % 1000);
                    } <span class="keyword">catch</span> (InterruptedException e) {
                        <span class="keyword">if</span> (!ringThreadToStop) {
                            logger.error(e.getMessage(), e);
                        }
                    }
                }
                logger.info(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, JobScheduleHelper#ringThread stop"</span>);
            }
        });
        ringThread.setDaemon(<span class="keyword">true</span>);
        ringThread.setName(<span class="string">"xxl-job, admin JobScheduleHelper#ringThread"</span>);
        ringThread.start();
    }

    <span class="keyword">private</span> <span class="keyword">void</span> refreshNextValidTime(XxlJobInfo jobInfo, Date fromTime) <span class="keyword">throws</span> ParseException {
        <span class="comment">// 创建一个 CronExpression 对象，使用 jobInfo 中获取的 Cron 表达式字符串初始化</span>
        Date nextValidTime = <span class="keyword">new</span> CronExpression(jobInfo.getJobCron()).getNextValidTimeAfter(fromTime);

        <span class="comment">// 检查计算出的下一次有效时间是否不为空</span>
        <span class="keyword">if</span> (nextValidTime != <span class="keyword">null</span>) {
            <span class="comment">// 如果有下一次有效时间，则更新任务信息的触发最后时间为当前的触发下一次时间</span>
            jobInfo.setTriggerLastTime(jobInfo.getTriggerNextTime());
            <span class="comment">// 更新任务信息的触发下一次时间为计算出的下一次有效时间的时间戳</span>
            jobInfo.setTriggerNextTime(nextValidTime.getTime());
        } <span class="keyword">else</span> {
            <span class="comment">// 如果没有下一次有效时间，说明 Cron 表达式可能无效或者已经过了所有触发时间</span>
            <span class="comment">// 设置任务状态为 0（可能是表示任务停止或者失效的状态，具体含义需要参考代码中其他部分）</span>
            jobInfo.setTriggerStatus(0);
            <span class="comment">// 将触发最后时间和触发下一次时间都设置为 0</span>
            jobInfo.setTriggerLastTime(0);
            jobInfo.setTriggerNextTime(0);
        }
    }
            </code></pre>

            <h4 id="section-trigger-task">触发任务</h4>
            <p>这段代码的主要功能是触发一个定时任务，并根据任务的执行情况选择不同的线程池来执行任务，同时监控任务的超时情况。以下是对代码段的详细解释</p>
            <pre class="java"><code>
<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> trigger(<span class="keyword">int</span> jobId, TriggerTypeEnum triggerType, <span class="keyword">int</span> failRetryCount, String executorShardingParam, String executorParam, String addressList) {
    helper.addTrigger(jobId, triggerType, failRetryCount, executorShardingParam, executorParam, addressList);
}

<span class="keyword">public</span> <span class="keyword">void</span> addTrigger(<span class="keyword">final</span> <span class="keyword">int</span> jobId,
                       <span class="keyword">final</span> TriggerTypeEnum triggerType,
                       <span class="keyword">final</span> <span class="keyword">int</span> failRetryCount,
                       <span class="keyword">final</span> String executorShardingParam,
                       <span class="keyword">final</span> String executorParam,
                       <span class="keyword">final</span> String addressList) {

    <span class="comment">// 选择线程池</span>
    ThreadPoolExecutor triggerPool_ = fastTriggerPool;
    AtomicInteger jobTimeoutCount = jobTimeoutCountMap.get(jobId);
    <span class="comment">// 如果jobId对应的任务超时次数超过10次/分钟</span>
    <span class="keyword">if</span> (jobTimeoutCount != <span class="keyword">null</span> && jobTimeoutCount.get() > 10) {
        <span class="comment">// 使用慢速线程池执行任务</span>
        triggerPool_ = slowTriggerPool;
    }

    <span class="comment">// trigger</span>
    triggerPool_.execute(<span class="keyword">new</span> Runnable() {
        @Override
        <span class="keyword">public</span> <span class="keyword">void</span> run() {

            <span class="keyword">long</span> start = System.currentTimeMillis();

            <span class="keyword">try</span> {
                <span class="comment">// 执行触发任务的逻辑</span>
                XxlJobTrigger.trigger(jobId, triggerType, failRetryCount, executorShardingParam, executorParam, addressList);
            } <span class="keyword">catch</span> (Exception e) {
                logger.error(e.getMessage(), e);
            } <span class="keyword">finally</span> {

                <span class="comment">// 检查并更新任务超时计数</span>
                <span class="keyword">long</span> minTim_now = System.currentTimeMillis() / 60000; <span class="comment">// 当前的分钟数</span>
                <span class="keyword">if</span> (minTim != minTim_now) { <span class="comment">// 如果时间已经过了新的一分钟</span>
                    minTim = minTim_now; <span class="comment">// 更新时间标记</span>
                    jobTimeoutCountMap.clear(); <span class="comment">// 清空超时计数映射，重置计数</span>
                }

                <span class="comment">// 计算任务执行耗时</span>
                <span class="keyword">long</span> cost = System.currentTimeMillis() - start;
                <span class="keyword">if</span> (cost > 500) { <span class="comment">// 如果任务执行耗时超过500毫秒</span>
                    <span class="comment">// 更新任务超时计数</span>
                    AtomicInteger timeoutCount = jobTimeoutCountMap.putIfAbsent(jobId, <span class="keyword">new</span> AtomicInteger(1));
                    <span class="keyword">if</span> (timeoutCount != <span class="keyword">null</span>) { <span class="comment">// 如果任务已经有过超时记录</span>
                        timeoutCount.incrementAndGet(); <span class="comment">// 超时次数加一</span>
                    }
                }

            }

        }
    });
}
            </code></pre>
            <p>其中 <code>XxlJobTrigger.trigger</code> 方法的源码解析如下：</p>
            <pre class="java"><code>
<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> trigger(<span class="keyword">int</span> jobId,
                           TriggerTypeEnum triggerType,
                           <span class="keyword">int</span> failRetryCount,
                           String executorShardingParam,
                           String executorParam,
                           String addressList) {

    <span class="comment">// 加载任务信息</span>
    XxlJobInfo jobInfo = XxlJobAdminConfig.getAdminConfig().getXxlJobInfoDao().loadById(jobId);
    <span class="comment">// 如果任务信息不存在，记录警告日志并返回</span>
    <span class="keyword">if</span> (jobInfo == <span class="keyword">null</span>) {
        logger.warn(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; trigger fail, jobId invalid，jobId={}"</span>, jobId);
        <span class="keyword">return</span>;
    }
    <span class="comment">// 如果有执行器参数，设置到任务信息中</span>
    <span class="keyword">if</span> (executorParam != <span class="keyword">null</span>) {
        jobInfo.setExecutorParam(executorParam);
    }
    <span class="comment">// 确定最终的失败重试次数</span>
    <span class="keyword">int</span> finalFailRetryCount = failRetryCount >= 0 ? failRetryCount : jobInfo.getExecutorFailRetryCount();
    <span class="comment">// 加载任务所属的执行器组信息</span>
    XxlJobGroup group = XxlJobAdminConfig.getAdminConfig().getXxlJobGroupDao().load(jobInfo.getJobGroup());

    <span class="comment">// 如果指定了地址列表，则覆盖执行器组的地址列表</span>
    <span class="keyword">if</span> (addressList != <span class="keyword">null</span> && addressList.trim().length() > 0) {
        group.setAddressType(1);
        group.setAddressList(addressList.trim());
    }

    <span class="comment">// 处理分片参数</span>
    <span class="keyword">int</span>[] shardingParam = <span class="keyword">null</span>;
    <span class="keyword">if</span> (executorShardingParam != <span class="keyword">null</span>) {
        String[] shardingArr = executorShardingParam.split(<span class="string">"/"</span>);
        <span class="comment">// 如果分片参数格式正确，转换为整型数组</span>
        <span class="keyword">if</span> (shardingArr.length == 2 && isNumeric(shardingArr[0]) && isNumeric(shardingArr[1])) {
            shardingParam = <span class="keyword">new</span> <span class="keyword">int</span>[2];
            shardingParam[0] = Integer.valueOf(shardingArr[0]);
            shardingParam[1] = Integer.valueOf(shardingArr[1]);
        }
    }
    <span class="comment">// 根据执行器路由策略和分片参数决定如何触发任务</span>
    <span class="comment">// ExecutorRouteStrategyEnum 枚举类定义了不同的路由策略</span>
    <span class="keyword">if</span> (ExecutorRouteStrategyEnum.SHARDING_BROADCAST == ExecutorRouteStrategyEnum.match(jobInfo.getExecutorRouteStrategy(), <span class="keyword">null</span>)
            && group.getRegistryList() != <span class="keyword">null</span> && !group.getRegistryList().isEmpty()
            && shardingParam == <span class="keyword">null</span>) {
        <span class="comment">// 广播策略，对每个注册中心都触发任务</span>
        <span class="keyword">for</span> (<span class="keyword">int</span> i = 0; i < group.getRegistryList().size(); i++) {
            processTrigger(group, jobInfo, finalFailRetryCount, triggerType, i, group.getRegistryList().size());
        }
    } <span class="keyword">else</span> {
        <span class="comment">// 如果没有分片参数，默认设置为0和1</span>
        <span class="keyword">if</span> (shardingParam == <span class="keyword">null</span>) {
            shardingParam = <span class="keyword">new</span> <span class="keyword">int</span>[]{0, 1};
        }
        <span class="comment">// 触发任务</span>
        processTrigger(group, jobInfo, finalFailRetryCount, triggerType, shardingParam[0], shardingParam[1]);
    }
}
            </code></pre>

            <h4 id="section-2-b-ii">ⅱ. 客户端接收并执行任务</h4>
            <p>根据我们在任务注册与心跳的章节中，介绍了 <code>EmbedServer</code>，这个类主要功能是启动一个嵌入式 HTTP 服务器，监听特定端口，处理 HTTP 请求，并将请求分发给业务逻辑线程池处理。同时，它还包含了服务器启动和关闭的相关逻辑。内部类 <code>EmbedHttpServerHandler</code> 继承了 <code>SimpleChannelInboundHandler</code> 抽象类，并重写了 <code>channelRead0</code> 方法。当通道接收到一个消息时，Netty 会自动调用该方法，并将接收到的消息传递给该方法。</p>
            <p>通过实现 <code>channelRead0</code> 方法，可以专注于处理接收到的消息，而不需要手动调用 <code>ctx.fireChannelRead</code> 来传递消息到下一个处理器。Netty 会自动处理消息的传递，简化了代码逻辑。</p>
            <p>在 <code>channelRead0</code> 方法执行完成后，Netty 会自动调用 <code>ReferenceCountUtil.release(msg)</code> 来释放接收到的消息的资源（如果消息是引用计数对象）。这减少了内存泄漏的风险。</p>
            <p>因此我们来看看 xxl-job 实现的 <code>channelRead0</code> 方法。</p>
            <pre class="java"><code>
@Override
<span class="keyword">protected</span> <span class="keyword">void</span> channelRead0(<span class="keyword">final</span> ChannelHandlerContext ctx, FullHttpRequest msg) <span class="keyword">throws</span> Exception {

    <span class="comment">// request parse</span>
    <span class="comment">//// 将请求内容从ByteBuf转换为UTF-8编码的字符串</span>
    String requestData = msg.content().toString(CharsetUtil.UTF_8);
    <span class="comment">// 获取请求的URI</span>
    String uri = msg.uri();
    <span class="comment">// 获取HTTP方法（如GET、POST等）</span>
    HttpMethod httpMethod = msg.method();
    <span class="comment">// 检查HTTP连接是否保持活跃，以便后续请求可以复用该连接</span>
    <span class="keyword">boolean</span> keepAlive = HttpUtil.isKeepAlive(msg);
    <span class="comment">// 从请求头中获取访问令牌</span>
    String accessTokenReq = msg.headers().get(XxlJobRemotingUtil.XXL_JOB_ACCESS_TOKEN);

    <span class="comment">// 在业务线程池中执行一个新的任务，这样可以提高服务器的并发处理能力。</span>
    bizThreadPool.execute(<span class="keyword">new</span> Runnable() {
        @Override
        <span class="keyword">public</span> <span class="keyword">void</span> run() {
            <span class="comment">// 处理HTTP请求，获取响应对象，调用的就是下面的process方法</span>
            Object responseObj = process(httpMethod, uri, requestData, accessTokenReq);

            <span class="comment">// to json</span>
            String responseJson = GsonTool.toJson(responseObj);

            <span class="comment">// 将JSON格式的响应写入到客户端</span>
            writeResponse(ctx, keepAlive, responseJson);
        }
    });
}

<span class="comment">// 主要功能是处理HTTP请求，并根据请求的URI执行相应的服务。</span>
<span class="keyword">private</span> Object process(HttpMethod httpMethod, String uri, String requestData, String accessTokenReq) {

    <span class="comment">// valid</span>
    <span class="keyword">if</span> (HttpMethod.POST != httpMethod) {
        <span class="keyword">return</span> <span class="keyword">new</span> ReturnT&lt;String&gt;(ReturnT.FAIL_CODE, <span class="string">"invalid request, HttpMethod not support."</span>);
    }
    <span class="keyword">if</span> (uri == <span class="keyword">null</span> || uri.trim().length() == 0) {
        <span class="keyword">return</span> <span class="keyword">new</span> ReturnT&lt;String&gt;(ReturnT.FAIL_CODE, <span class="string">"invalid request, uri-mapping empty."</span>);
    }
    <span class="keyword">if</span> (accessToken != <span class="keyword">null</span>
            && accessToken.trim().length() > 0
            && !accessToken.equals(accessTokenReq)) {
        <span class="keyword">return</span> <span class="keyword">new</span> ReturnT&lt;String&gt;(ReturnT.FAIL_CODE, <span class="string">"The access token is wrong."</span>);
    }

    <span class="comment">// 根据URI映射执行相应的服务</span>
    <span class="keyword">try</span> {
        <span class="comment">// 如果URI为"/beat"，执行心跳检测服务</span>
        <span class="keyword">if</span> (<span class="string">"/beat"</span>.equals(uri)) {
            <span class="keyword">return</span> executorBiz.beat();
        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"/idleBeat"</span>.equals(uri)) {
            <span class="comment">// 如果URI为"/idleBeat"，执行空闲心跳服务</span>
            IdleBeatParam idleBeatParam = GsonTool.fromJson(requestData, IdleBeatParam.class);
            <span class="keyword">return</span> executorBiz.idleBeat(idleBeatParam);
        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"/run"</span>.equals(uri)) {
            <span class="comment">// 如果URI为"/run"，执行任务触发服务。</span>
            <span class="comment">// 这里调用的是com.xxl.job.core.biz.impl.ExecutorBizImpl#run 方法</span>
            TriggerParam triggerParam = GsonTool.fromJson(requestData, TriggerParam.class);
            <span class="keyword">return</span> executorBiz.run(triggerParam);
        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"/kill"</span>.equals(uri)) {
            <span class="comment">// 如果URI为"/kill"，执行任务杀死服务</span>
            KillParam killParam = GsonTool.fromJson(requestData, KillParam.class);
            <span class="keyword">return</span> executorBiz.kill(killParam);
        } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"/log"</span>.equals(uri)) {
            <span class="comment">// 如果URI为"/log"，执行日志查询服务</span>
            LogParam logParam = GsonTool.fromJson(requestData, LogParam.class);
            <span class="keyword">return</span> executorBiz.log(logParam);
        } <span class="keyword">else</span> {
            <span class="comment">// 如果URI不匹配上述任何一项，则返回失败信息</span>
            <span class="keyword">return</span> <span class="keyword">new</span> ReturnT&lt;String&gt;(ReturnT.FAIL_CODE, <span class="string">"invalid request, uri-mapping(" + uri + ") not found."</span>);
        }
    } <span class="keyword">catch</span> (Exception e) {
        logger.error(e.getMessage(), e);
        <span class="keyword">return</span> <span class="keyword">new</span> ReturnT&lt;String&gt;(ReturnT.FAIL_CODE, <span class="string">"request error:"</span> + ThrowableUtil.toString(e));
    }
}
            </code></pre>
            <p>任务调度的方法：<code>com.xxl.job.core.biz.impl.ExecutorBizImpl#run</code></p>
            <pre class="java"><code>
@Override
<span class="keyword">public</span> ReturnT&lt;String&gt; run(TriggerParam triggerParam) {
    <span class="comment">// 加载旧的jobHandler和jobThread</span>
    JobThread jobThread = XxlJobExecutor.loadJobThread(triggerParam.getJobId());
    IJobHandler jobHandler = jobThread != <span class="keyword">null</span> ? jobThread.getHandler() : <span class="keyword">null</span>;
    String removeOldReason = <span class="keyword">null</span>;

    <span class="comment">// 验证jobHandler和jobThread的有效性，并根据不同的glueType处理</span>
    GlueTypeEnum glueTypeEnum = GlueTypeEnum.match(triggerParam.getGlueType());
    <span class="comment">// GlueTypeEnum 定义了不同的运行模式，</span>
    <span class="comment">// 是BEAN，表示作业处理器是一个Java Bean。</span>
    <span class="keyword">if</span> (GlueTypeEnum.BEAN == glueTypeEnum) {

        <span class="comment">// 新的 jobhandler</span>
        IJobHandler newJobHandler = XxlJobExecutor.loadJobHandler(triggerParam.getExecutorHandler());

        <span class="comment">// 如果旧的jobThread存在且其handler与新加载的不相同，则需要终止旧的线程。</span>
        <span class="keyword">if</span> (jobThread != <span class="keyword">null</span> && jobHandler != newJobHandler) {
            removeOldReason = <span class="string">"change jobhandler or glue type, and terminate the old job thread."</span>;

            jobThread = <span class="keyword">null</span>;
            jobHandler = <span class="keyword">null</span>;
        }

        <span class="comment">// valid handler</span>
        <span class="keyword">if</span> (jobHandler == <span class="keyword">null</span>) {
            jobHandler = newJobHandler;
            <span class="keyword">if</span> (jobHandler == <span class="keyword">null</span>) {
                <span class="keyword">return</span> <span class="keyword">new</span> ReturnT&lt;String&gt;(ReturnT.FAIL_CODE, <span class="string">"job handler ["</span> + triggerParam.getExecutorHandler() + <span class="string">"] not found."</span>);
            }
        }

    } <span class="keyword">else</span> <span class="keyword">if</span> (GlueTypeEnum.GLUE_GROOVY == glueTypeEnum) {
        <span class="comment">// 是GLUE_GROOVY类型，表示作业处理器是由Groovy脚本定义的。</span>
        <span class="comment">// GLUE_GROOVY == GLUE(Java)</span>
        <span class="comment">// 检查Groovy脚本是否有更新，如果有，则需要终止旧的线程并加载新的脚本。</span>
        <span class="keyword">if</span> (jobThread != <span class="keyword">null</span> &&
                !(jobThread.getHandler() <span class="keyword">instanceof</span> GlueJobHandler
                        && ((GlueJobHandler) jobThread.getHandler()).getGlueUpdatetime() == triggerParam.getGlueUpdatetime())) {
            <span class="comment">// change handler or gluesource updated, need kill old thread</span>
            removeOldReason = <span class="string">"change job source or glue type, and terminate the old job thread."</span>;

            jobThread = <span class="keyword">null</span>;
            jobHandler = <span class="keyword">null</span>;
        }

        <span class="comment">// valid handler</span>
        <span class="keyword">if</span> (jobHandler == <span class="keyword">null</span>) {
            <span class="keyword">try</span> {
                IJobHandler originJobHandler = GlueFactory.getInstance().loadNewInstance(triggerParam.getGlueSource());
                jobHandler = <span class="keyword">new</span> GlueJobHandler(originJobHandler, triggerParam.getGlueUpdatetime());
            } <span class="keyword">catch</span> (Exception e) {
                logger.error(e.getMessage(), e);
                <span class="keyword">return</span> <span class="keyword">new</span> ReturnT&lt;String&gt;(ReturnT.FAIL_CODE, e.getMessage());
            }
        }
    } <span class="keyword">else</span> <span class="keyword">if</span> (glueTypeEnum != <span class="keyword">null</span> && glueTypeEnum.isScript()) {
        <span class="comment">// 如果是脚本类型（如.sh .py .php .js .ps1），同样检查脚本是否有更新，如果有，则需要终止旧的线程并加载新的脚本。</span>
        <span class="keyword">if</span> (jobThread != <span class="keyword">null</span> &&
                !(jobThread.getHandler() <span class="keyword">instanceof</span> ScriptJobHandler
                        && ((ScriptJobHandler) jobThread.getHandler()).getGlueUpdatetime() == triggerParam.getGlueUpdatetime())) {
            <span class="comment">// change script or gluesource updated, need kill old thread</span>
            removeOldReason = <span class="string">"change job source or glue type, and terminate the old job thread."</span>;

            jobThread = <span class="keyword">null</span>;
            jobHandler = <span class="keyword">null</span>;
        }

        <span class="comment">// valid handler</span>
        <span class="keyword">if</span> (jobHandler == <span class="keyword">null</span>) {
            jobHandler = <span class="keyword">new</span> ScriptJobHandler(triggerParam.getJobId(), triggerParam.getGlueUpdatetime(), triggerParam.getGlueSource(), GlueTypeEnum.match(triggerParam.getGlueType()));
        }
    } <span class="keyword">else</span> {
        <span class="keyword">return</span> <span class="keyword">new</span> ReturnT&lt;String&gt;(ReturnT.FAIL_CODE, <span class="string">"glueType["</span> + triggerParam.getGlueType() + <span class="string">"] is not valid."</span>);
    }

    <span class="comment">// 调度器的阻塞策略，决定如何处理正在运行或排队中的作业线程</span>
    <span class="keyword">if</span> (jobThread != <span class="keyword">null</span>) {
        <span class="comment">// 根据triggerParam.getExecutorBlockStrategy()返回的值来匹配相应的阻塞策略枚举值。如果没有匹配到有效的策略，则返回null。</span>
        ExecutorBlockStrategyEnum blockStrategy = ExecutorBlockStrategyEnum.match(triggerParam.getExecutorBlockStrategy(), <span class="keyword">null</span>);
        <span class="comment">// 阻塞策略是DISCARD_LATER（稍后丢弃），则检查当前任务线程jobThread是否正在运行或者有排队中的任务。</span>
        <span class="comment">// 如果是，则返回一个失败的响应，提示阻塞策略的效果是稍后丢弃当前任务。</span>
        <span class="keyword">if</span> (ExecutorBlockStrategyEnum.DISCARD_LATER == blockStrategy) {
            <span class="comment">// 当任务正在运行或有排队任务时，丢弃当前触发</span>
            <span class="keyword">if</span> (jobThread.isRunningOrHasQueue()) {
                <span class="keyword">return</span> <span class="keyword">new</span> ReturnT&lt;String&gt;(ReturnT.FAIL_CODE, <span class="string">"block strategy effect："</span> + ExecutorBlockStrategyEnum.DISCARD_LATER.getTitle());
            }
        } <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorBlockStrategyEnum.COVER_EARLY == blockStrategy) {
            <span class="comment">// 如果阻塞策略是COVER_EARLY（提前覆盖），同样检查当前任务线程jobThread是否正在运行或者有排队中的任务。</span>
            <span class="comment">// 如果是，则将jobThread设置为null，表示终止当前运行的任务线程，并记录移除旧任务的原因。</span>
            <span class="keyword">if</span> (jobThread.isRunningOrHasQueue()) {
                removeOldReason = <span class="string">"block strategy effect："</span> + ExecutorBlockStrategyEnum.COVER_EARLY.getTitle();

                jobThread = <span class="keyword">null</span>;
            }
        } <span class="keyword">else</span> {
            <span class="comment">// 默认情况下，任务将会排队等待执行</span>
        }
    }

    <span class="comment">// 替换线程</span>
    <span class="keyword">if</span> (jobThread == <span class="keyword">null</span>) {
        jobThread = XxlJobExecutor.registJobThread(triggerParam.getJobId(), jobHandler, removeOldReason);
    }

    <span class="comment">// 将数据推送到队列</span>
    ReturnT&lt;String&gt; pushResult = jobThread.pushTriggerQueue(triggerParam);
    <span class="keyword">return</span> pushResult;
}
            </code></pre>
            <p>最后 <code>jobThread</code> 开始执行</p>
            <p>主要负责处理定时任务的执行</p>
            <pre class="java"><code>
@Override
<span class="keyword">public</span> <span class="keyword">void</span> run() {

    <span class="comment">// 尝试初始化任务处理器 handler，这里会通过反射调用方法</span>
    <span class="keyword">try</span> {
        handler.init();
    } <span class="keyword">catch</span> (Throwable e) {
        logger.error(e.getMessage(), e);
    }

    <span class="comment">// execute</span>
    <span class="keyword">while</span> (!toStop) {
        running = <span class="keyword">false</span>;
        idleTimes++;

        TriggerParam triggerParam = <span class="keyword">null</span>;
        ReturnT&lt;String&gt; executeResult = <span class="keyword">null</span>;
        <span class="keyword">try</span> {
            <span class="comment">// 使用 triggerQueue.poll(3L, TimeUnit.SECONDS) 方法尝试从任务队列中获取触发参数 triggerParam，如果在3秒内没有获取到，则继续下一次循环。</span>
            <span class="comment">// triggerQueue 就是上一步在ExecutorBizImpl类中，任务数据写进去的队列</span>
            triggerParam = triggerQueue.poll(3L, TimeUnit.SECONDS);
            <span class="keyword">if</span> (triggerParam != <span class="keyword">null</span>) {
                <span class="comment">// 更新 running 和 idleTimes 状态。</span>
                running = <span class="keyword">true</span>;
                idleTimes = 0;
                <span class="comment">// 移除已经处理的日志ID。</span>
                triggerLogIdSet.remove(triggerParam.getLogId());

                <span class="comment">// 设置日志文件名和分片信息。</span>
                String logFileName = XxlJobFileAppender.makeLogFileName(<span class="keyword">new</span> Date(triggerParam.getLogDateTime()), triggerParam.getLogId());
                <span class="comment">// 记录任务开始执行的日志。</span>
                <span class="comment">// 这样做是为了确保在多线程环境下，每个线程都能将日志记录到正确的文件中。</span>
                <span class="comment">// 通过设置线程局部变量，可以隔离不同线程间的日志记录，避免日志混淆。</span>
                XxlJobFileAppender.contextHolder.set(logFileName);
                <span class="comment">// 设置分片信息</span>
                /**
                 * 这行代码使用ShardingUtil类的setShardingVo方法来设置分片信息。
                 * 这里创建了一个ShardingVO对象，它包含了两个属性：
                 * triggerParam.getBroadcastIndex()表示当前任务的广播索引，
                 * triggerParam.getBroadcastTotal()表示广播的总数。
                 * 这种分片机制通常用于分布式系统中，以实现任务的并行处理和负载均衡。
                 */
                ShardingUtil.setShardingVo(<span class="keyword">new</span> ShardingUtil.ShardingVO(triggerParam.getBroadcastIndex(), triggerParam.getBroadcastTotal()));

                <span class="comment">// execute</span>
                XxlJobLogger.log(<span class="string">"&lt;br&gt;----------- xxl-job job execute start -----------&lt;br&gt;----------- Param:"</span> + triggerParam.getExecutorParams());
                <span class="comment">// 根据 triggerParam 中的超时设置，决定是直接执行任务还是使用 FutureTask 来限制执行时间。</span>
                <span class="keyword">if</span> (triggerParam.getExecutorTimeout() > 0) {
                    <span class="comment">// 表示需要限制任务的执行超时时间。这里使用FutureTask</span>
                    Thread futureThread = <span class="keyword">null</span>;
                    <span class="keyword">try</span> {
                        <span class="keyword">final</span> TriggerParam triggerParamTmp = triggerParam;
                        FutureTask&lt;ReturnT&lt;String&gt;&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;ReturnT&lt;String&gt;&gt;(<span class="keyword">new</span> Callable&lt;ReturnT&lt;String&gt;&gt;() {
                            @Override
                            <span class="keyword">public</span> ReturnT&lt;String&gt; call() <span class="keyword">throws</span> Exception {
                                <span class="comment">// 执行任务，这里有很多实现类，对应不同的方法</span>
                                <span class="comment">// glue、method、script三种不同类型</span>
                                <span class="keyword">return</span> handler.execute(triggerParamTmp.getExecutorParams());
                            }
                        });
                        futureThread = <span class="keyword">new</span> Thread(futureTask);
                        futureThread.start();

                        <span class="comment">// get方法的第一个参数是等待任务完成的最大时间，第二个参数是时间单位。这里使用的是triggerParam中的executorTimeout值，单位是秒。</span>
                        executeResult = futureTask.get(triggerParam.getExecutorTimeout(), TimeUnit.SECONDS);
                    } <span class="keyword">catch</span> (TimeoutException e) {

                        XxlJobLogger.log(<span class="string">"&lt;br&gt;----------- xxl-job job execute timeout"</span>);
                        XxlJobLogger.log(e);

                        executeResult = <span class="keyword">new</span> ReturnT&lt;String&gt;(IJobHandler.FAIL_TIMEOUT.getCode(), <span class="string">"job execute timeout "</span>);
                    } <span class="keyword">finally</span> {
                        futureThread.interrupt();
                    }
                } <span class="keyword">else</span> {
                    <span class="comment">// 没有设置超时时间，直接执行</span>
                    executeResult = handler.execute(triggerParam.getExecutorParams());
                }

                <span class="comment">// 执行的结果</span>
                <span class="keyword">if</span> (executeResult == <span class="keyword">null</span>) {
                    executeResult = IJobHandler.FAIL;
                } <span class="keyword">else</span> {
                    executeResult.setMsg(
                            (executeResult != <span class="keyword">null</span> && executeResult.getMsg() != <span class="keyword">null</span> && executeResult.getMsg().length() > 50000)
                                    ? executeResult.getMsg().substring(0, 50000).concat(<span class="string">"..."</span>)
                                    : executeResult.getMsg());
                    executeResult.setContent(<span class="keyword">null</span>); <span class="comment">// limit obj size</span>
                }
                XxlJobLogger.log(<span class="string">"&lt;br&gt;----------- xxl-job job execute end(finish) -----------&lt;br&gt;----------- ReturnT:"</span> + executeResult);

            } <span class="keyword">else</span> {
                <span class="comment">// 如果在指定的空闲时间内(30s)没有获取到任务，则检查是否需要移除空闲时间过长的任务线程。</span>
                <span class="keyword">if</span> (idleTimes > 30) {
                    <span class="keyword">if</span> (triggerQueue.size() == 0) {
                        XxlJobExecutor.removeJobThread(jobId, <span class="string">"excutor idel times over limit."</span>);
                    }
                }
            }
        } <span class="keyword">catch</span> (Throwable e) {
            <span class="comment">// 异常处理，记录日志，设置任务结果为失败</span>
            <span class="keyword">if</span> (toStop) {
                XxlJobLogger.log(<span class="string">"&lt;br&gt;----------- JobThread toStop, stopReason:"</span> + stopReason);
            }

            StringWriter stringWriter = <span class="keyword">new</span> StringWriter();
            e.printStackTrace(<span class="keyword">new</span> PrintWriter(stringWriter));
            String errorMsg = stringWriter.toString();
            executeResult = <span class="keyword">new</span> ReturnT&lt;String&gt;(ReturnT.FAIL_CODE, errorMsg);

            XxlJobLogger.log(<span class="string">"&lt;br&gt;----------- JobThread Exception:"</span> + errorMsg + <span class="string">"&lt;br&gt;----------- xxl-job job execute end(error) -----------"</span>);
        } <span class="keyword">finally</span> {
            <span class="keyword">if</span> (triggerParam != <span class="keyword">null</span>) {
                <span class="comment">// 回调处理，把执行结果推送到回调线程中</span>
                <span class="comment">// 回调的处理是在com.xxl.job.core.thread.TriggerCallbackThread#start 中，这个方法在客户端启动的时候就已经开启了线程，在任务注册中有分析。</span>
                <span class="keyword">if</span> (!toStop) {
                    <span class="comment">// common</span>
                    TriggerCallbackThread.pushCallBack(<span class="keyword">new</span> HandleCallbackParam(triggerParam.getLogId(), triggerParam.getLogDateTime(), executeResult));
                } <span class="keyword">else</span> {
                    <span class="comment">// is killed</span>
                    ReturnT&lt;String&gt; stopResult = <span class="keyword">new</span> ReturnT&lt;String&gt;(ReturnT.FAIL_CODE, stopReason + <span class="string">" [job running, killed]"</span>);
                    TriggerCallbackThread.pushCallBack(<span class="keyword">new</span> HandleCallbackParam(triggerParam.getLogId(), triggerParam.getLogDateTime(), stopResult));
                }
            }
        }
    }

    <span class="comment">// callback trigger request in queue</span>
    <span class="keyword">while</span> (triggerQueue != <span class="keyword">null</span> && triggerQueue.size() > 0) {
        TriggerParam triggerParam = triggerQueue.poll();
        <span class="keyword">if</span> (triggerParam != <span class="keyword">null</span>) {
            <span class="comment">// 如果任务被终止，则创建一个返回结果对象，表示任务未能执行，因为它在队列中就被终止了</span>
            ReturnT&lt;String&gt; stopResult = <span class="keyword">new</span> ReturnT&lt;String&gt;(ReturnT.FAIL_CODE, stopReason + <span class="string">" [job not executed, in the job queue, killed.]"</span>);
            <span class="comment">// 将处理回调参数对象推送到触发回调线程中，以便进行后续的回调处理</span>
            TriggerCallbackThread.pushCallBack(<span class="keyword">new</span> HandleCallbackParam(triggerParam.getLogId(), triggerParam.getLogDateTime(), stopResult));
        }
    }

    <span class="comment">// destroy</span>
    <span class="keyword">try</span> {
        handler.destroy();
    } <span class="keyword">catch</span> (Throwable e) {
        logger.error(e.getMessage(), e);
    }

    logger.info(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job JobThread stoped, hashCode:{}"</span>, Thread.currentThread());
}
            </code></pre>

            <div class="article-tags">
                <a href="#">XXL-JOB</a>
                <a href="#">任务调度</a>
                <a href="#">源码分析</a>
                <a href="#">分布式系统</a>
            </div>
        </section>
    </main>
    <aside>
        <section class="section toc">
            <h3>文章目录</h3>
            <ul>
                <li><a href="#section-2">任务调度</a>
                    <ul>
                        <li><a href="#section-2-a">a. 整体调度流程概述</a></li>
                        <li><a href="#section-2-b">b. 源码分析</a>
                            <ul>
                                <li><a href="#section-2-b-i">ⅰ. 调度中心的任务调度</a></li>
                                <li><a href="#section-2-b-ii">ⅱ. 客户端接收并执行任务</a></li>
                            </ul>
                        </li>
                    </ul>
                </li>
            </ul>
        </section>
        <section class="section tags">
            <h3>文章标签</h3>
            <div>
                <a href="#" class="article-tags">XXL-JOB</a>
                <a href="#" class="article-tags">任务调度</a>
                <a href="#" class="article-tags">源码分析</a>
                <a href="#" class="article-tags">分布式系统</a>
            </div>
        </section>
        <section class="section hot-posts">
            <h3>热门文章</h3>
            <ul>
                <li><a href="#">Spring Boot 3.3实战</a></li>
                <li><a href="#">Hibernate性能优化</a></li>
                <li><a href="#">Java并发编程入门</a></li>
            </ul>
        </section>
    </aside>
</div>
<footer>
    <div class="social">
        <a href="#" aria-label="WeChat"><i class="fab fa-weixin"></i></a>
        <a href="#" aria-label="Weibo"><i class="fab fa-weibo"></i></a>
        <a href="#" aria-label="QQ"><i class="fab fa-qq"></i></a>
    </div>
    <p>联系方式：<a href="/cdn-cgi/l/email-protection">[email protected]</a> | <a href="#">服务条款</a></p>
    <p>© 2025 Java技术站 版权所有</p>
</footer>
</body>
</html>