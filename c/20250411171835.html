<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="referrer" content="no-referrer">
    <title>XXL-JOB任务调度源码分析</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        body {
            font-family: 'PingFang SC', Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #F7F9FC;
            color: #333;
            line-height: 1.6;
            overflow-x: hidden;
            box-sizing: border-box;
        }
        .top-bar {
            background: linear-gradient(135deg, #7B68EE, #4A90E2);
            padding: 15px 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            position: fixed;
            width: 100%;
            top: 0;
            z-index: 1000;
            box-sizing: border-box;
        }
        .top-bar h1 {
            margin: 0;
            font-size: 1.8em;
            color: white;
        }
        nav {
            background-color: #FFFFFF;
            padding: 15px 0;
            position: fixed;
            top: 60px;
            width: 100%;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
            z-index: 999;
            box-sizing: border-box;
        }
        nav .nav-toggle {
            display: none;
            font-size: 1.5em;
            color: #4A90E2;
            cursor: pointer;
            padding: 10px 20px;
        }
        nav ul {
            list-style-type: none;
            padding: 0;
            display: flex;
            justify-content: center;
            margin: 0;
        }
        nav li {
            position: relative;
            margin: 0 20px;
        }
        nav a {
            text-decoration: none;
            color: #4A90E2;
            font-weight: bold;
            padding: 10px 15px;
            display: flex;
            align-items: center;
            transition: color 0.3s;
        }
        nav a:hover {
            color: #F5A623;
        }
        nav i {
            margin-right: 8px;
        }
        nav .dropdown {
            display: none;
            position: absolute;
            background-color: #FFFFFF;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            min-width: 150px;
            top: 100%;
            left: 0;
            border-radius: 8px;
        }
        nav li:hover .dropdown {
            display: block;
        }
        nav .dropdown a {
            padding: 10px;
            color: #4A90E2;
            font-weight: normal;
        }
        nav .dropdown a:hover {
            background-color: #E9F1FF;
            color: #F5A623;
        }
        .container {
            max-width: 1500px;
            margin: 120px auto 20px;
            display: flex;
            gap: 30px;
            padding: 0 20px;
            box-sizing: border-box;
        }
        main {
            flex: 2;
            max-width: 100%;
        }
        aside {
            width: 350px;
            flex-shrink: 0;
            max-width: 100%;
        }
        .section {
            background-color: #FFFFFF;
            padding: 25px;
            margin-bottom: 20px;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
            margin-top: 40px;
            box-sizing: border-box;
        }
        .section h1 {
            color: #4A90E2;
            font-size: 2.5em;
            margin: 0 0 15px;
            word-wrap: break-word;
        }
        .section h2 {
            color: #4A90E2;
            font-size: 1.8em;
            margin: 25px 0 15px;
            word-wrap: break-word;
        }
        .section h3 {
            color: #333;
            font-size: 1.2em;
            margin: 20px 0 10px;
            word-wrap: break-word;
        }
        .article-meta {
            font-size: 0.9em;
            color: #666;
            margin: 10px 0;
        }
        .article-content p {
            margin: 15px 0;
            word-wrap: break-word;
        }
        .article-content pre {
            background-color: #2D2D2D;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Consolas', 'Courier New', monospace;
            font-size: 0.95em;
            color: #ABB2BF;
            border: 1px solid #404040;
            white-space: pre-wrap;
            word-break: break-word;
            max-width: 100%;
            box-sizing: border-box;
            overflow-x: auto;
        }
        .article-content pre code {
            display: block;
        }
        .article-content pre.java span.keyword {
            color: #E5C07B;
        }
        .article-content pre.java span.string {
            color: #98C379;
        }
        .article-content pre.java span.comment {
            color: #5C6370;
        }
        .article-content code {
            background-color: #333;
            color: #E9ECEF;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Consolas', 'Courier New', monospace;
            word-wrap: break-word;
        }
        .article-content blockquote {
            background-color: #F5F6F5;
            border-left: 4px solid #4A90E2;
            padding: 10px 15px;
            margin: 15px 0;
            color: #555;
            border-radius: 4px;
            word-wrap: break-word;
            font-size: 0.95em;
            font-style: italic;
        }
        .article-content img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 15px 0;
            border-radius: 8px;
        }
        .article-content ol {
            padding-left: 20px;
        }
        .article-content ol ol {
            list-style-type: lower-alpha;
        }
        .article-content ol ol ol {
            list-style-type: lower-roman;
        }
        .article-content ol ol ol ol {
            list-style: decimal;
        }
        .article-content ol ol ol ol ol {
            list-style-type: lower-alpha;
        }
        .article-tags {
            margin: 20px 0;
        }
        .article-tags a {
            display: inline-block;
            padding: 5px 10px;
            margin-right: 5px;
            background-color: #E9F1FF;
            color: #4A90E2;
            border-radius: 12px;
            text-decoration: none;
            font-size: 0.85em;
        }
        aside .section {
            padding: 20px;
            box-sizing: border-box;
        }
        aside ul {
            list-style-type: none;
            padding: 0;
        }
        aside li {
            margin: 10px 0;
        }
        aside .toc ul ul {
            margin-left: 20px;
        }
        aside .toc ul ul ul {
            margin-left: 40px;
        }
        aside a {
            color: #4A90E2;
            text-decoration: none;
            transition: color 0.3s;
            word-wrap: break-word;
        }
        aside a:hover {
            color: #F5A623;
        }
        .toc h3, .tags h3, .hot-posts h3 {
            color: #4A90E2;
            font-size: 1.6em;
            margin: 0 0 15px;
        }
        .toc-toggle {
            display: none;
            font-size: 1.5em;
            color: #4A90E2;
            cursor: pointer;
            position: fixed;
            top: 120px;
            right: 20px;
            z-index: 1001;
            background: #FFFFFF;
            padding: 10px;
            border-radius: 50%;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        footer {
            background: linear-gradient(135deg, #7B68EE, #4A90E2);
            color: white;
            padding: 30px;
            text-align: center;
            border-radius: 15px 15px 0 0;
            margin-top: 20px;
            box-sizing: border-box;
            width: 100%;
        }
        footer .social a {
            color: #F5A623;
            margin: 0 10px;
            font-size: 1.5em;
            transition: color 0.3s;
        }
        footer .social a:hover {
            color: #FF7F50;
        }

        /* Mobile Styles */
        @media (max-width: 768px) {
            body {
                overflow-x: hidden;
            }
            .top-bar h1 {
                font-size: 1.4em;
            }
            nav {
                padding: 10px 0;
                top: 50px;
            }
            nav .nav-toggle {
                display: block;
            }
            nav ul {
                display: none;
                flex-direction: column;
                padding: 10px;
            }
            nav ul.active {
                display: flex;
            }
            nav li {
                margin: 5px 0;
            }
            nav a {
                padding: 10px;
            }
            nav .dropdown {
                position: static;
                box-shadow: none;
                background: #F7F9FC;
            }
            .container {
                flex-direction: column;
                margin-top: 100px;
                padding: 0 10px;
            }
            main {
                flex: 1;
            }
            aside {
                width: 100%;
            }
            .toc-toggle {
                display: block;
            }
            aside .toc {
                display: none;
                position: fixed;
                top: 100px;
                right: 0;
                width: 80%;
                max-width: 300px;
                background: #FFFFFF;
                box-shadow: -2px 0 5px rgba(0, 0, 0, 0.2);
                padding: 20px;
                z-index: 1000;
            }
            aside .toc.active {
                display: block;
            }
            footer {
                padding: 20px;
            }
            footer .social a {
                font-size: 1.2em;
                margin: 0 8px;
            }
            footer p {
                font-size: 0.9em;
            }
        }
    </style>
</head>
<body>
<div class="top-bar">
    <h1>Java技术站</h1>
</div>
<nav>
    <i class="fas fa-bars nav-toggle"></i>
    <ul>
        <li><a href="#"><i class="fas fa-code"></i> 核心Java</a></li>
        <li><a href="#"><i class="fas fa-leaf"></i> Spring框架</a>
            <div class="dropdown">
                <a href="#">Spring Boot</a>
                <a href="#">Spring Security</a>
            </div>
        </li>
        <li><a href="#"><i class="fas fa-database"></i> 持久化技术</a></li>
        <li><a href="#"><i class="fas fa-tools"></i> 构建工具</a></li>
        <li><a href="#"><i class="fas fa-cloud"></i> 微服务与云</a></li>
        <li><a href="#"><i class="fas fa-file"></i> 源码研究</a>
            <div class="dropdown">
                <a href="../xxljob-sourcel-index.html">XXL-JOB</a>
                <a href="../sentinel-index.html">Sentinel</a>
            </div>
        </li>
        <li><a href="online-issues-index.html"><i class="fas fa-bug"></i> 线上问题记录</a></li>
    </ul>
</nav>
<div class="container">
    <main>
        <section class="section article-content">
            <h1>XXL-JOB任务调度源码分析</h1>
            <div class="article-meta">发布于：2025-04-11</div>
            <p>上一篇我们介绍了 <a href="20250411161955.html" target="_blank"> XXL-JOB原理及任务注册与心跳源码分析</a> 。这篇文章介绍XXL-JOB是如何进行任务调度的</p>
            <h2 id="section-2">任务调度</h2>

            <h3 id="section-2-a">a. 整体调度流程概述</h3>
            <p>XXL-JOB 的调度主要分为调度中心和执行器两部分。调度中心负责任务的管理、调度触发；执行器负责接收调度中心的任务请求并执行具体的任务。整体流程如下：</p>
            <ol>
                <li>调度中心根据任务的配置（如 Cron 表达式）计算任务的下次执行时间。</li>
                <li>到达任务执行时间时，调度中心向对应的执行器发送调度请求。</li>
                <li>执行器接收到调度请求后，执行具体的任务逻辑。</li>
                <li>执行器将任务执行结果反馈给调度中心。</li>
            </ol>

            <h3 id="section-2-b">b. 源码分析</h3>

            <h4 id="section-2-b-i">ⅰ. 调度中心的任务调度</h4>
            <p>在调度中心启动时，会初始化任务调度相关的组件，初始化组件是在 <code>XxlJobScheduler</code> 类中的 <code>init()</code> 方法。而任务调度主要在 <code>JobScheduleHelper</code> 类的 <code>start</code> 方法中完成：</p>
            <p><strong>方法逻辑</strong>：主要是负责启动两个线程：<code>scheduleThread</code> 和 <code>ringThread</code>，用于处理定时任务的调度和触发。</p>
            <p>这里去掉了部分代码，只保留主要逻辑</p>
            <pre class="java"><code>
public void start() {

    // schedule 线程的作用
    // 1. 初始化调度器：线程启动后，首先会等待直到当前时间的毫秒数为0，然后输出初始化成功的日志
    // 2. 预读取任务：计算预读取任务的数量，这个数量基于触发器线程池的大小和QPS（每秒查询率）。
    scheduleThread = new Thread(new Runnable() {
        @Override
        public void run() {

            // pre-read count: treadpool-size * trigger-qps (each trigger cost 50ms, qps = 1000/50 = 20)
            int preReadCount = (XxlJobAdminConfig.getAdminConfig().getTriggerPoolFastMax() + XxlJobAdminConfig.getAdminConfig().getTriggerPoolSlowMax()) * 20;

            while (!scheduleThreadToStop) {

                Connection conn = null;
                Boolean connAutoCommit = null;
                PreparedStatement preparedStatement = null;

                boolean preReadSuc = true;
                try {

                    // 获取数据库连接，并设置为手动提交事务。
                    conn = XxlJobAdminConfig.getAdminConfig().getDataSource().getConnection();
                    connAutoCommit = conn.getAutoCommit();
                    conn.setAutoCommit(false);

                    // 尝试获取调度锁，以确保同一时间只有一个线程在执行调度任务
                    preparedStatement = conn.prepareStatement("select * from xxl_job_lock where lock_name = 'schedule_lock' for update");
                    preparedStatement.execute();

                    // tx start

                    // 1、pre read
                    long nowTime = System.currentTimeMillis();
                    List<XxlJobInfo> scheduleList = XxlJobAdminConfig.getAdminConfig().getXxlJobInfoDao().scheduleJobQuery(nowTime + PRE_READ_MS, preReadCount);
                    if (scheduleList != null && scheduleList.size() > 0) {
                        // 2、push time-ring
                        for (XxlJobInfo jobInfo : scheduleList) {

                            // time-ring jump
                            if (nowTime > jobInfo.getTriggerNextTime() + PRE_READ_MS) {

                                // 刷新下一个任务的时间
                                refreshNextValidTime(jobInfo, new Date());

                            } else if (nowTime > jobInfo.getTriggerNextTime()) {
                                // 当前时间大于任务的下一个触发时间，但未超过预设的提前读取时间

                                // 触发任务
                                JobTriggerPoolHelper.trigger(jobInfo.getId(), TriggerTypeEnum.CRON, -1, null, null, null);

                                // 刷新下一个任务的时间
                                refreshNextValidTime(jobInfo, new Date());

                                // 检查是否需要在5秒内再次预读
                                if (jobInfo.getTriggerStatus() == 1 && nowTime + PRE_READ_MS > jobInfo.getTriggerNextTime()) {

                                    // 1、计算秒
                                    int ringSecond = (int) ((jobInfo.getTriggerNextTime() / 1000) % 60);

                                    // 2、推送时间环
                                    pushTimeRing(ringSecond, jobInfo.getId());

                                    // 3、刷新下一个任务的时间
                                    refreshNextValidTime(jobInfo, new Date(jobInfo.getTriggerNextTime()));

                                }

                            } else {
                                // 如果当前时间还未到达任务的下一个触发时间。

                                // 1、计算环秒数
                                int ringSecond = (int) ((jobInfo.getTriggerNextTime() / 1000) % 60);

                                // 2、推送时间环。
                                pushTimeRing(ringSecond, jobInfo.getId());

                                // 3、刷新下一个任务的时间
                                refreshNextValidTime(jobInfo, new Date(jobInfo.getTriggerNextTime()));

                            }

                        }

                        // 3、更新调度列表中的触发器信息
                        for (XxlJobInfo jobInfo : scheduleList) {
                            XxlJobAdminConfig.getAdminConfig().getXxlJobInfoDao().scheduleUpdate(jobInfo);
                        }

                    } else {
                        preReadSuc = false;
                    }

                    // tx stop

                } catch (Exception e) {
                    if (!scheduleThreadToStop) {
                        logger.error(">>>>>>>>>>> xxl-job, JobScheduleHelper#scheduleThread error:{}", e);
                    }
                } finally {

                    // commit

                }

            }
        }
    });
    scheduleThread.setDaemon(true);
    scheduleThread.setName("xxl-job, admin JobScheduleHelper#scheduleThread");
    scheduleThread.start();

    // 初始化时间环：线程启动后，首先会等待直到当前时间的毫秒数为0。
    ringThread = new Thread(new Runnable() {
        @Override
        public void run() {

            while (!ringThreadToStop) {

                try {
                    // second data
                    List<Integer> ringItemData = new ArrayList<>();
                    // 避免处理耗时太长，跨过刻度，向前校验一个刻度；
                    int nowSecond = Calendar.getInstance().get(Calendar.SECOND);
                    for (int i = 0; i < 2; i++) {
                        // 从ringData中移除并获取当前秒和前一秒的任务列表。
                        List<Integer> tmpData = ringData.remove((nowSecond + 60 - i) % 60);
                        if (tmpData != null) {
                            ringItemData.addAll(tmpData);
                        }
                    }

                    if (ringItemData.size() > 0) {
                        // 如果ringItemData中有任务ID，表示有任务需要触发。
                        for (int jobId : ringItemData) {
                            // 触发任务
                            JobTriggerPoolHelper.trigger(jobId, TriggerTypeEnum.CRON, -1, null, null, null);
                        }
                        // clear
                        ringItemData.clear();
                    }
                } catch (Exception e) {
                    if (!ringThreadToStop) {
                        logger.error(">>>>>>>>>>> xxl-job, JobScheduleHelper#ringThread error:{}", e);
                    }
                }

                // 再次对齐秒数，准备进入下一个循环。
                try {
                    TimeUnit.MILLISECONDS.sleep(1000 - System.currentTimeMillis() % 1000);
                } catch (InterruptedException e) {
                    if (!ringThreadToStop) {
                        logger.error(e.getMessage(), e);
                    }
                }
            }
            logger.info(">>>>>>>>>>> xxl-job, JobScheduleHelper#ringThread stop");
        }
    });
    ringThread.setDaemon(true);
    ringThread.setName("xxl-job, admin JobScheduleHelper#ringThread");
    ringThread.start();
}

private void refreshNextValidTime(XxlJobInfo jobInfo, Date fromTime) throws ParseException {
    // 创建一个 CronExpression 对象，使用 jobInfo 中获取的 Cron 表达式字符串初始化
    Date nextValidTime = new CronExpression(jobInfo.getJobCron()).getNextValidTimeAfter(fromTime);

    // 检查计算出的下一次有效时间是否不为空
    if (nextValidTime != null) {
        // 如果有下一次有效时间，则更新任务信息的触发最后时间为当前的触发下一次时间
        jobInfo.setTriggerLastTime(jobInfo.getTriggerNextTime());
        // 更新任务信息的触发下一次时间为计算出的下一次有效时间的时间戳
        jobInfo.setTriggerNextTime(nextValidTime.getTime());
    } else {
        // 如果没有下一次有效时间，说明 Cron 表达式可能无效或者已经过了所有触发时间
        // 设置任务状态为 0（可能是表示任务停止或者失效的状态，具体含义需要参考代码中其他部分）
        jobInfo.setTriggerStatus(0);
        // 将触发最后时间和触发下一次时间都设置为 0
        jobInfo.setTriggerLastTime(0);
        jobInfo.setTriggerNextTime(0);
    }
}
            </code></pre>

            <h4 id="section-trigger-task">触发任务</h4>
            <p>这段代码的主要功能是触发一个定时任务，并根据任务的执行情况选择不同的线程池来执行任务，同时监控任务的超时情况。以下是对代码段的详细解释</p>
            <pre class="java"><code>
public static void trigger(int jobId, TriggerTypeEnum triggerType, int failRetryCount, String executorShardingParam, String executorParam, String addressList) {
    helper.addTrigger(jobId, triggerType, failRetryCount, executorShardingParam, executorParam, addressList);
}

public void addTrigger(final int jobId,
                      final TriggerTypeEnum triggerType,
                      final int failRetryCount,
                      final String executorShardingParam,
                      final String executorParam,
                      final String addressList) {

    // 选择线程池
    ThreadPoolExecutor triggerPool_ = fastTriggerPool;
    AtomicInteger jobTimeoutCount = jobTimeoutCountMap.get(jobId);
    // 如果jobId对应的任务超时次数超过10次/分钟
    if (jobTimeoutCount != null && jobTimeoutCount.get() > 10) {
        // 使用慢速线程池执行任务
        triggerPool_ = slowTriggerPool;
    }

    // trigger
    triggerPool_.execute(new Runnable() {
        @Override
        public void run() {

            long start = System.currentTimeMillis();

            try {
                // 执行触发任务的逻辑
                XxlJobTrigger.trigger(jobId, triggerType, failRetryCount, executorShardingParam, FILLER
executorParam, addressList);
            } catch (Exception e) {
                logger.error(e.getMessage(), e);
            } finally {

                // 检查并更新任务超时计数
                long minTim_now = System.currentTimeMillis() / 60000; // 当前的分钟数
                if (minTim != minTim_now) { // 如果时间已经过了新的一分钟
                    minTim = minTim_now; // 更新时间标记
                    jobTimeoutCountMap.clear(); // 清空超时计数映射，重置计数
                }

                // 计算任务执行耗时
                long cost = System.currentTimeMillis() - start;
                if (cost > 500) { // 如果任务执行耗时超过500毫秒
                    // 更新任务超时计数
                    AtomicInteger timeoutCount = jobTimeoutCountMap.putIfAbsent(jobId, new AtomicInteger(1));
                    if (timeoutCount != null) { // 如果任务已经有过超时记录
                        timeoutCount.incrementAndGet(); // 超时次数加一
                    }
                }

            }

        }
    });
}
            </code></pre>
            <p>其中 <code>XxlJobTrigger.trigger</code> 方法的源码解析如下：</p>
            <pre class="java"><code>
public static void trigger(int jobId,
                          TriggerTypeEnum triggerType,
                          int failRetryCount,
                          String executorShardingParam,
                          String executorParam,
                          String addressList) {

    // 加载任务信息
    XxlJobInfo jobInfo = XxlJobAdminConfig.getAdminConfig().getXxlJobInfoDao().loadById(jobId);
    // 如果任务信息不存在，记录警告日志并返回
    if (jobInfo == null) {
        logger.warn(">>>>>>>>>>> trigger fail, jobId invalid，jobId={}", jobId);
        return;
    }
    // 如果有执行器参数，设置到任务信息中
    if (executorParam != null) {
        jobInfo.setExecutorParam(executorParam);
    }
    // 确定最终的失败重试次数
    int finalFailRetryCount = failRetryCount >= 0 ? failRetryCount : jobInfo.getExecutorFailRetryCount();
    // 加载任务所属的执行器组信息
    XxlJobGroup group = XxlJobAdminConfig.getAdminConfig().getXxlJobGroupDao().load(jobInfo.getJobGroup());

    // 如果指定了地址列表，则覆盖执行器组的地址列表
    if (addressList != null && addressList.trim().length() > 0) {
        group.setAddressType(1);
        group.setAddressList(addressList.trim());
    }

    // 处理分片参数
    int[] shardingParam = null;
    if (executorShardingParam != null) {
        String[] shardingArr = executorShardingParam.split("/");
        // 如果分片参数格式正确，转换为整型数组
        if (shardingArr.length == 2 && isNumeric(shardingArr[0]) && isNumeric(shardingArr[1])) {
            shardingParam = new int[2];
            shardingParam[0] = Integer.valueOf(shardingArr[0]);
            shardingParam[1] = Integer.valueOf(shardingArr[1]);
        }
    }
    // 根据执行器路由策略和分片参数决定如何触发任务
    // ExecutorRouteStrategyEnum 枚举类定义了不同的路由策略
    if (ExecutorRouteStrategyEnum.SHARDING_BROADCAST == ExecutorRouteStrategyEnum.match(jobInfo.getExecutorRouteStrategy(), null)
            && group.getRegistryList() != null && !group.getRegistryList().isEmpty()
            && shardingParam == null) {
        // 广播策略，对每个注册中心都触发任务
        for (int i = 0; i < group.getRegistryList().size(); i++) {
            processTrigger(group, jobInfo, finalFailRetryCount, triggerType, i, group.getRegistryList().size());
        }
    } else {
        // 如果没有分片参数，默认设置为0和1
        if (shardingParam == null) {
            shardingParam = new int[]{0, 1};
        }
        // 触发任务
        processTrigger(group, jobInfo, finalFailRetryCount, triggerType, shardingParam[0], shardingParam[1]);
    }
}
            </code></pre>

            <h4 id="section-2-b-ii">ⅱ. 客户端接收并执行任务</h4>
            <p>根据我们在任务注册与心跳的章节中，介绍了 <code>EmbedServer</code>，这个类主要功能是启动一个嵌入式 HTTP 服务器，监听特定端口，处理 HTTP 请求，并将请求分发给业务逻辑线程池处理。同时，它还包含了服务器启动和关闭的相关逻辑。内部类 <code>EmbedHttpServerHandler</code> 继承了 <code>SimpleChannelInboundHandler</code> 抽象类，并重写了 <code>channelRead0</code> 方法。当通道接收到一个消息时，Netty 会自动调用该方法，并将接收到的消息传递给该方法。</p>
            <p>通过实现 <code>channelRead0</code> 方法，可以专注于处理接收到的消息，而不需要手动调用 <code>ctx.fireChannelRead</code> 来传递消息到下一个处理器。Netty 会自动处理消息的传递，简化了代码逻辑。</p>
            <p>在 <code>channelRead0</code> 方法执行完成后，Netty 会自动调用 <code>ReferenceCountUtil.release(msg)</code> 来释放接收到的消息的资源（如果消息是引用计数对象）。这减少了内存泄漏的风险。</p>
            <p>因此我们来看看 xxl-job 实现的 <code>channelRead0</code> 方法。</p>
            <pre class="java"><code>
@Override
protected void channelRead0(final ChannelHandlerContext ctx, FullHttpRequest msg) throws Exception {

    // request parse
    //// 将请求内容从ByteBuf转换为UTF-8编码的字符串
    String requestData = msg.content().toString(CharsetUtil.UTF_8);
    // 获取请求的URI
    String uri = msg.uri();
    // 获取HTTP方法（如GET、POST等）
    HttpMethod httpMethod = msg.method();
    // 检查HTTP连接是否保持活跃，以便后续请求可以复用该连接
    boolean keepAlive = HttpUtil.isKeepAlive(msg);
    // 从请求头中获取访问令牌
    String accessTokenReq = msg.headers().get(XxlJobRemotingUtil.XXL_JOB_ACCESS_TOKEN);

    // 在业务线程池中执行一个新的任务，这样可以提高服务器的并发处理能力。
    bizThreadPool.execute(new Runnable() {
        @Override
        public void run() {
            // 处理HTTP请求，获取响应对象，调用的就是下面的process方法
            Object responseObj = process(httpMethod, uri, requestData, accessTokenReq);

            // to json
            String responseJson = GsonTool.toJson(responseObj);

            // 将JSON格式的响应写入到客户端
            writeResponse(ctx, keepAlive, responseJson);
        }
    });
}

// 主要功能是处理HTTP请求，并根据请求的URI执行相应的服务。
private Object process(HttpMethod httpMethod, String uri, String requestData, String accessTokenReq) {

    // valid
    if (HttpMethod.POST != httpMethod) {
        return new ReturnT<String>(ReturnT.FAIL_CODE, "invalid request, HttpMethod not support.");
    }
    if (uri == null || uri.trim().length() == 0) {
        return new ReturnT<String>(ReturnT.FAIL_CODE, "invalid request, uri-mapping empty.");
    }
    if (accessToken != null
            && accessToken.trim().length() > 0
            && !accessToken.equals(accessTokenReq)) {
        return new ReturnT<String>(ReturnT.FAIL_CODE, "The access token is wrong.");
    }

    // 根据URI映射执行相应的服务
    try {
        // 如果URI为"/beat"，执行心跳检测服务
        if ("/beat".equals(uri)) {
            return executorBiz.beat();
        } else if ("/idleBeat".equals(uri)) {
            // 如果URI为"/idleBeat"，执行空闲心跳服务
            IdleBeatParam idleBeatParam = GsonTool.fromJson(requestData, IdleBeatParam.class);
            return executorBiz.idleBeat(idleBeatParam);
        } else if ("/run".equals(uri)) {
            // 如果URI为"/run"，执行任务触发服务。
            // 这里调用的是com.xxl.job.core.biz.impl.ExecutorBizImpl#run 方法
            TriggerParam triggerParam = GsonTool.fromJson(requestData, TriggerParam.class);
            return executorBiz.run(triggerParam);
        } else if ("/kill".equals(uri)) {
            // 如果URI为"/kill"，执行任务杀死服务
            KillParam killParam = GsonTool.fromJson(requestData, KillParam.class);
            return executorBiz.kill(killParam);
        } else if ("/log".equals(uri)) {
            // 如果URI为"/log"，执行日志查询服务
            LogParam logParam = GsonTool.fromJson(requestData, LogParam.class);
            return executorBiz.log(logParam);
        } else {
            // 如果URI不匹配上述任何一项，则返回失败信息
            return new ReturnT<String>(ReturnT.FAIL_CODE, "invalid request, uri-mapping(" + uri + ") not found.");
        }
    } catch (Exception e) {
        logger.error(e.getMessage(), e);
        return new ReturnT<String>(ReturnT.FAIL_CODE, "request error:" + ThrowableUtil.toString(e));
    }
}
            </code></pre>
            <p>任务调度的方法：<code>com.xxl.job.core.biz.impl.ExecutorBizImpl#run</code></p>
            <pre class="java"><code>
@Override
public ReturnT<String> run(TriggerParam triggerParam) {
    // 加载旧的jobHandler和jobThread
    JobThread jobThread = XxlJobExecutor.loadJobThread(triggerParam.getJobId());
    IJobHandler jobHandler = jobThread != null ? jobThread.getHandler() : null;
    String removeOldReason = null;

    // 验证jobHandler和jobThread的有效性，并根据不同的glueType处理
    GlueTypeEnum glueTypeEnum = GlueTypeEnum.match(triggerParam.getGlueType());
    // GlueTypeEnum 定义了不同的运行模式，
    // 是BEAN，表示作业处理器是一个Java Bean。
    if (GlueTypeEnum.BEAN == glueTypeEnum) {

        // 新的 jobhandler
        IJobHandler newJobHandler = XxlJobExecutor.loadJobHandler(triggerParam.getExecutorHandler());

        // 如果旧的jobThread存在且其handler与新加载的不相同，则需要终止旧的线程。
        if (jobThread != null && jobHandler != newJobHandler) {
            removeOldReason = "change jobhandler or glue type, and terminate the old job thread.";

            jobThread = null;
            jobHandler = null;
        }

        // valid handler
        if (jobHandler == null) {
            jobHandler = newJobHandler;
            if (jobHandler == null) {
                return new ReturnT<String>(ReturnT.FAIL_CODE, "job handler [" + triggerParam.getExecutorHandler() + "] not found.");
            }
        }

    } else if (GlueTypeEnum.GLUE_GROOVY == glueTypeEnum) {
        // 是GLUE_GROOVY类型，表示作业处理器是由Groovy脚本定义的。
        // GLUE_GROOVY == GLUE(Java)
        // 检查Groovy脚本是否有更新，如果有，则需要终止旧的线程并加载新的脚本。
        if (jobThread != null &&
                !(jobThread.getHandler() instanceof GlueJobHandler
                        && ((GlueJobHandler) jobThread.getHandler()).getGlueUpdatetime() == triggerParam.getGlueUpdatetime())) {
            // change handler or gluesource updated, need kill old thread
            removeOldReason = "change job source or glue type, and terminate the old job thread.";

            jobThread = null;
            jobHandler = null;
        }

        // valid handler
        if (jobHandler == null) {
            try {
                IJobHandler originJobHandler = GlueFactory.getInstance().loadNewInstance(triggerParam.getGlueSource());
                jobHandler = new GlueJobHandler(originJobHandler, triggerParam.getGlueUpdatetime());
            } catch (Exception e) {
                logger.error(e.getMessage(), e);
                return new ReturnT<String>(ReturnT.FAIL_CODE, e.getMessage());
            }
        }
    } else if (glueTypeEnum != null && glueTypeEnum.isScript()) {
        // 如果是脚本类型（如.sh .py .php .js .ps1），同样检查脚本是否有更新，如果有，则需要终止旧的线程并加载新的脚本。
        if (jobThread != null &&
                !(jobThread.getHandler() instanceof ScriptJobHandler
                        && ((ScriptJobHandler) jobThread.getHandler()).getGlueUpdatetime() == triggerParam.getGlueUpdatetime())) {
            // change script or gluesource updated, need kill old thread
            removeOldReason = "change job source or glue type, and terminate the old job thread.";

            jobThread = null;
            jobHandler = null;
        }

        // valid handler
        if (jobHandler == null) {
            jobHandler = new ScriptJobHandler(triggerParam.getJobId(), triggerParam.getGlueUpdatetime(), triggerParam.getGlueSource(), GlueTypeEnum.match(triggerParam.getGlueType()));
        }
    } else {
        return new ReturnT<String>(ReturnT.FAIL_CODE, "glueType[" + triggerParam.getGlueType() + "] is not valid.");
    }

    // 调度器的阻塞策略，决定如何处理正在运行或排队中的作业线程
    if (jobThread != null) {
        // 根据triggerParam.getExecutorBlockStrategy()返回的值来匹配相应的阻塞策略枚举值。如果没有匹配到有效的策略，则返回null。
        ExecutorBlockStrategyEnum blockStrategy = ExecutorBlockStrategyEnum.match(triggerParam.getExecutorBlockStrategy(), null);
        // 阻塞策略是DISCARD_LATER（稍后丢弃），则检查当前任务线程jobThread是否正在运行或者有排队中的任务。
        // 如果是，则返回一个失败的响应，提示阻塞策略的效果是稍后丢弃当前任务。
        if (ExecutorBlockStrategyEnum.DISCARD_LATER == blockStrategy) {
            // 当任务正在运行或有排队任务时，丢弃当前触发
            if (jobThread.isRunningOrHasQueue()) {
                return new ReturnT<String>(ReturnT.FAIL_CODE, "block strategy effect：" + ExecutorBlockStrategyEnum.DISCARD_LATER.getTitle());
            }
        } else if (ExecutorBlockStrategyEnum.COVER_EARLY == blockStrategy) {
            // 如果阻塞策略是COVER_EARLY（提前覆盖），同样检查当前任务线程jobThread是否正在运行或者有排队中的任务。
            // 如果是，则将jobThread设置为null，表示终止当前运行的任务线程，并记录移除旧任务的原因。
            if (jobThread.isRunningOrHasQueue()) {
                removeOldReason = "block strategy effect：" + ExecutorBlockStrategyEnum.COVER_EARLY.getTitle();

                jobThread = null;
            }
        } else {
            // 默认情况下，任务将会排队等待执行
        }
    }

    // 替换线程
    if (jobThread == null) {
        jobThread = XxlJobExecutor.registJobThread(triggerParam.getJobId(), jobHandler, removeOldReason);
    }

    // 将数据推送到队列
    ReturnT<String> pushResult = jobThread.pushTriggerQueue(triggerParam);
    return pushResult;
}
            </code></pre>
            <p>最后 <code>jobThread</code> 开始执行</p>
            <p>主要负责处理定时任务的执行</p>
            <pre class="java"><code>
@Override
public void run() {

    // 尝试初始化任务处理器 handler，这里会通过反射调用方法
    try {
        handler.init();
    } catch (Throwable e) {
        logger.error(e.getMessage(), e);
    }

    // execute
    while (!toStop) {
        running = false;
        idleTimes++;

        TriggerParam triggerParam = null;
        ReturnT<String> executeResult = null;
        try {
            // 使用 triggerQueue.poll(3L, TimeUnit.SECONDS) 方法尝试从任务队列中获取触发参数 triggerParam，如果在3秒内没有获取到，则继续下一次循环。
            // triggerQueue 就是上一步在ExecutorBizImpl类中，任务数据写进去的队列
            triggerParam = triggerQueue.poll(3L, TimeUnit.SECONDS);
            if (triggerParam != null) {
                // 更新 running 和 idleTimes 状态。
                running = true;
                idleTimes = 0;
                // 移除已经处理的日志ID。
                triggerLogIdSet.remove(triggerParam.getLogId());

                // 设置日志文件名和分片信息。
                String logFileName = XxlJobFileAppender.makeLogFileName(new Date(triggerParam.getLogDateTime()), triggerParam.getLogId());
                // 记录任务开始执行的日志。
                // 这样做是为了确保在多线程环境下，每个线程都能将日志记录到正确的文件中。
                // 通过设置线程局部变量，可以隔离不同线程间的日志记录，避免日志混淆。
                XxlJobFileAppender.contextHolder.set(logFileName);
                // 设置分片信息
                /**
                 * 这行代码使用ShardingUtil类的setShardingVo方法来设置分片信息。
                 * 这里创建了一个ShardingVO对象，它包含了两个属性：
                 * triggerParam.getBroadcastIndex()表示当前任务的广播索引，
                 * triggerParam.getBroadcastTotal()表示广播的总数。
                 * 这种分片机制通常用于分布式系统中，以实现任务的并行处理和负载均衡。
                 */
                ShardingUtil.setShardingVo(new ShardingUtil.ShardingVO(triggerParam.getBroadcastIndex(), triggerParam.getBroadcastTotal()));

                // execute
                XxlJobLogger.log("<br>----------- xxl-job job execute start -----------<br>----------- Param:" + triggerParam.getExecutorParams());
                // 根据 triggerParam 中的超时设置，决定是直接执行任务还是使用 FutureTask 来限制执行时间。
                if (triggerParam.getExecutorTimeout() > 0) {
                    // 表示需要限制任务的执行超时时间。这里使用FutureTask
                    Thread futureThread = null;
                    try {
                        final TriggerParam triggerParamTmp = triggerParam;
                        FutureTask<ReturnT<String>> futureTask = new FutureTask<ReturnT<String>>(new Callable<ReturnT<String>>() {
                            @Override
                            public ReturnT<String> call() throws Exception {
                                // 执行任务，这里有很多实现类，对应不同的方法
                                // glue、method、script三种不同类型
                                return handler.execute(triggerParamTmp.getExecutorParams());
                            }
                        });
                        futureThread = new Thread(futureTask);
                        futureThread.start();

                        // get方法的第一个参数是等待任务完成的最大时间，第二个参数是时间单位。这里使用的是triggerParam中的executorTimeout值，单位是秒。
                        executeResult = futureTask.get(triggerParam.getExecutorTimeout(), TimeUnit.SECONDS);
                    } catch (TimeoutException e) {

                        XxlJobLogger.log("<br>----------- xxl-job job execute timeout");
                        XxlJobLogger.log(e);

                        executeResult = new ReturnT<String>(IJobHandler.FAIL_TIMEOUT.getCode(), "job execute timeout ");
                    } finally {
                        futureThread.interrupt();
                    }
                } else {
                    // 没有设置超时时间，直接执行
                    executeResult = handler.execute(triggerParam.getExecutorParams());
                }

                // 执行的结果
                if (executeResult == null) {
                    executeResult = IJobHandler.FAIL;
                } else {
                    executeResult.setMsg(
                            (executeResult != null && executeResult.getMsg() != null && executeResult.getMsg().length() > 50000)
                                    ? executeResult.getMsg().substring(0, 50000).concat("...")
                                    : executeResult.getMsg());
                    executeResult.setContent(null); // limit obj size
                }
                XxlJobLogger.log("<br>----------- xxl-job job execute end(finish) -----------<br>----------- ReturnT:" + executeResult);

            } else {
                // 如果在指定的空闲时间内(30s)没有获取到任务，则检查是否需要移除空闲时间过长的任务线程。
                if (idleTimes > 30) {
                    if (triggerQueue.size() == 0) {
                        XxlJobExecutor.removeJobThread(jobId, "excutor idel times over limit.");
                    }
                }
            }
        } catch (Throwable e) {
            // 异常处理，记录日志，设置任务结果为失败
            if (toStop) {
                XxlJobLogger.log("<br>----------- JobThread toStop, stopReason:" + stopReason);
            }

            StringWriter stringWriter = new StringWriter();
            e.printStackTrace(new PrintWriter(stringWriter));
            String errorMsg = stringWriter.toString();
            executeResult = new ReturnT<String>(ReturnT.FAIL_CODE, errorMsg);

            XxlJobLogger.log("<br>----------- JobThread Exception:" + errorMsg + "<br>----------- xxl-job job execute end(error) -----------");
        } finally {
            if (triggerParam != null) {
                // 回调处理，把执行结果推送到回调线程中
                // 回调的处理是在com.xxl.job.core.thread.TriggerCallbackThread#start 中，这个方法在客户端启动的时候就已经开启了线程，在任务注册中有分析。
                if (!toStop) {
                    // common
                    TriggerCallbackThread.pushCallBack(new HandleCallbackParam(triggerParam.getLogId(), triggerParam.getLogDateTime(), executeResult));
                } else {
                    // is killed
                    ReturnT<String> stopResult = new ReturnT<String>(ReturnT.FAIL_CODE, stopReason + " [job running, killed]");
                    TriggerCallbackThread.pushCallBack(new HandleCallbackParam(triggerParam.getLogId(), triggerParam.getLogDateTime(), stopResult));
                }
            }
        }
    }

    // callback trigger request in queue
    while (triggerQueue != null && triggerQueue.size() > 0) {
        TriggerParam triggerParam = triggerQueue.poll();
        if (triggerParam != null) {
            // 如果任务被终止，则创建一个返回结果对象，表示任务未能执行，因为它在队列中就被终止了
            ReturnT<String> stopResult = new ReturnT<String>(ReturnT.FAIL_CODE, stopReason + " [job not executed, in the job queue, killed.]");
            // 将处理回调参数对象推送到触发回调线程中，以便进行后续的回调处理
            TriggerCallbackThread.pushCallBack(new HandleCallbackParam(triggerParam.getLogId(), triggerParam.getLogDateTime(), stopResult));
        }
    }

    // destroy
    try {
        handler.destroy();
    } catch (Throwable e) {
        logger.error(e.getMessage(), e);
    }

    logger.info(">>>>>>>>>>> xxl-job JobThread stoped, hashCode:{}", Thread.currentThread());
}
            </code></pre>

            <div class="article-tags">
                <a href="../xxljob-sourcel-index.html">XXL-JOB</a>
                <a href="#">任务调度</a>
                <a href="../xxljob-sourcel-index.html">XXL-JOB</a>
                <a href="#">分布式系统</a>
            </div>
        </section>
    </main>
    <aside>
        <i class="fas fa-list toc-toggle"></i>
        <section class="section toc">
            <h3>文章目录</h3>
            <ul>
                <li><a href="#section-2">任务调度</a>
                    <ul>
                        <li><a href="#section-2-a">a. 整体调度流程概述</a></li>
                        <li><a href="#section-2-b">b. 源码分析</a>
                            <ul>
                                <li><a href="#section-2-b-i">ⅰ. 调度中心的任务调度</a></li>
                                <li><a href="#section-2-b-ii">ⅱ. 客户端接收并执行任务</a></li>
                            </ul>
                        </li>
                    </ul>
                </li>
            </ul>
        </section>
        <section class="section tags">
            <h3>文章标签</h3>
            <div>
                <a href="#" class="article-tags">XXL-JOB</a>
                <a href="#" class="article-tags">任务调度</a>
                <a href="#" class="article-tags">源码分析</a>
                <a href="#" class="article-tags">分布式系统</a>
            </div>
        </section>
        <section class="section hot-posts">
            <h3>热门文章</h3>
            <ul>
                <li><a href="#">Spring Boot 3.3实战</a></li>
                <li><a href="#">Hibernate性能优化</a></li>
                <li><a href="#">Java并发编程入门</a></li>
            </ul>
        </section>
    </aside>
</div>
<footer>
    <div class="social">
        <a href="#" aria-label="WeChat"><i class="fab fa-weixin"></i></a>
        <a href="#" aria-label="Weibo"><i class="fab fa-weibo"></i></a>
        <a href="#" aria-label="QQ"><i class="fab fa-qq"></i></a>
    </div>
    <p>联系方式：<a href="/cdn-cgi/l/email-protection">[email protected]</a> | <a href="#">服务条款</a></p>
    <p>© 2025 Java技术站 版权所有</p>
</footer>
<script>
    // Navigation menu toggle
    const navToggle = document.querySelector('.nav-toggle');
    const navMenu = document.querySelector('nav ul');
    navToggle.addEventListener('click', () => {
        navMenu.classList.toggle('active');
    });

    // TOC toggle for mobile
    const tocToggle = document.querySelector('.toc-toggle');
    const toc = document.querySelector('.toc');
    tocToggle.addEventListener('click', () => {
        toc.classList.toggle('active');
    });

    // TOC smooth scrolling
    const tocItems = document.querySelectorAll('.toc li a');
    tocItems.forEach(item => {
        item.addEventListener('click', (e) => {
            e.preventDefault();
            const targetId = item.getAttribute('href').substring(1);
            const targetElement = document.getElementById(targetId);
            if (targetElement) {
                window.scrollTo({
                    top: targetElement.offsetTop - 100,
                    behavior: 'smooth'
                });
            }
        });
    });
</script>
</body>
</html>