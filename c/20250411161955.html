<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="referrer" content="no-referrer">
    <title>XXL-JOB原理及任务注册与心跳源码分析</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        body {
            font-family: 'PingFang SC', Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #F7F9FC;
            color: #333;
            line-height: 1.6;
            overflow-x: hidden;
        }
        .top-bar {
            background: linear-gradient(135deg, #7B68EE, #4A90E2);
            padding: 15px 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            position: fixed;
            width: 100%;
            top: 0;
            z-index: 1000;
            box-sizing: border-box;
        }
        .top-bar h1 {
            margin: 0;
            font-size: 1.8em;
            color: white;
        }
        nav {
            background-color: #FFFFFF;
            padding: 15px 0;
            position: fixed;
            top: 60px;
            width: 100%;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
            z-index: 999;
            box-sizing: border-box;
        }
        nav ul {
            list-style-type: none;
            padding: 0;
            display: flex;
            justify-content: center;
            margin: 0;
        }
        nav li {
            position: relative;
            margin: 0 20px;
        }
        nav a {
            text-decoration: none;
            color: #4A90E2;
            font-weight: bold;
            padding: 10px 15px;
            display: flex;
            align-items: center;
            transition: color 0.3s;
        }
        nav a:hover {
            color: #F5A623;
        }
        nav i {
            margin-right: 8px;
        }
        nav .dropdown {
            display: none;
            position: absolute;
            background-color: #FFFFFF;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            min-width: 150px;
            top: 100%;
            left: 0;
            border-radius: 8px;
        }
        nav li:hover .dropdown {
            display: block;
        }
        nav .dropdown a {
            padding: 10px;
            color: #4A90E2;
            font-weight: normal;
        }
        nav .dropdown a:hover {
            background-color: #E9F1FF;
            color: #F5A623;
        }
        .container {
            max-width: 1500px;
            margin: 120px auto 20px;
            display: flex;
            gap: 30px;
            padding: 0 20px;
            box-sizing: border-box;
        }
        main {
            flex: 2;
            max-width: 100%;
        }
        aside {
            width: 350px;
            flex-shrink: 0;
            max-width: 100%;
        }
        .section {
            background-color: #FFFFFF;
            padding: 25px;
            margin-bottom: 20px;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
            margin-top: 40px;
            box-sizing: border-box;
        }
        .section h1 {
            color: #4A90E2;
            font-size: 2.5em;
            margin: 0 0 15px;
            word-wrap: break-word;
        }
        .section h2 {
            color: #4A90E2;
            font-size: 1.8em;
            margin: 25px 0 15px;
            word-wrap: break-word;
        }
        .section h3 {
            color: #333;
            font-size: 1.2em;
            margin: 20px 0 10px;
            word-wrap: break-word;
        }
        .article-meta {
            font-size: 0.9em;
            color: #666;
            margin: 10px 0;
        }
        .article-content p {
            margin: 15px 0;
            word-wrap: break-word;
        }
        .article-content pre {
            background-color: #2D2D2D;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Consolas', 'Courier New', monospace;
            font-size: 0.95em;
            color: #ABB2BF;
            border: 1px solid #404040;
            white-space: pre-wrap;
            word-break: break-word;
            max-width: 100%;
            box-sizing: border-box;
            overflow-x: hidden;
        }
        .article-content pre code {
            display: block;
        }
        .article-content pre.java span.keyword {
            color: #E5C07B;
        }
        .article-content pre.java span.string {
            color: #98C379;
        }
        .article-content pre.java span.comment {
            color: #5C6370;
        }
        .article-content code {
            background-color: #333;
            color: #E9ECEF;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Consolas', 'Courier New', monospace;
            word-wrap: break-word;
        }
        .article-content blockquote {
            background-color: #F5F6F5;
            border-left: 4px solid #4A90E2;
            padding: 15px;
            margin: 15px 0;
            color: #555;
            border-radius: 4px;
            word-wrap: break-word;
            font-size: 0.95em;
            line-height: 1.5;
            position: relative;
        }
        .article-content blockquote::before {
            content: '“';
            font-size: 1.5em;
            color: #4A90E2;
            position: absolute;
            top: 10px;
            left: 10px;
        }
        .article-content img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 15px 0;
            border-radius: 8px;
        }
        .article-content ol {
            padding-left: 20px;
        }
        .article-content ol li {
            margin: 10px 0;
        }
        .article-content ol ol {
            list-style-type: lower-alpha;
        }
        .article-content ol ol ol {
            list-style-type: lower-roman;
        }
        .article-content ol ol ol ol {
            list-style-type: decimal;
        }
        .article-content ol ol ol ol ol {
            list-style-type: lower-alpha;
        }
        .article-tags {
            margin: 20px 0;
        }
        .article-tags a {
            display: inline-block;
            padding: 5px 10px;
            margin-right: 5px;
            background-color: #E9F1FF;
            color: #4A90E2;
            border-radius: 12px;
            text-decoration: none;
            font-size: 0.85em;
        }
        aside .section {
            padding: 20px;
            box-sizing: border-box;
        }
        aside ul {
            list-style-type: none;
            padding: 0;
        }
        aside li {
            margin: 10px 0;
        }
        aside .toc ul ul {
            margin-left: 15px;
        }
        aside .toc ul ul ul {
            margin-left: 30px;
        }
        aside a {
            color: #4A90E2;
            text-decoration: none;
            transition: color 0.3s;
            word-wrap: break-word;
        }
        aside a:hover {
            color: #F5A623;
        }
        .toc h3, .tags h3, .hot-posts h3 {
            color: #4A90E2;
            font-size: 1.6em;
            margin: 0 0 15px;
        }
        footer {
            background: linear-gradient(135deg, #7B68EE, #4A90E2);
            color: white;
            padding: 30px;
            text-align: center;
            border-radius: 15px 15px 0 0;
            margin-top: 20px;
            box-sizing: border-box;
            width: 100%;
        }
        footer .social a {
            color: #F5A623;
            margin: 0 10px;
            font-size: 1.5em;
            transition: color 0.3s;
        }
        footer .social a:hover {
            color: #FF7F50;
        }
    </style>
</head>
<body>
<div class="top-bar">
    <h1>Java技术站</h1>
</div>
<nav>
    <ul>
        <li><a href="#"><i class="fas fa-code"></i> 核心Java</a></li>
        <li><a href="#"><i class="fas fa-leaf"></i> Spring框架</a>
            <div class="dropdown">
                <a href="#">Spring Boot</a>
                <a href="#">Spring Security</a>
            </div>
        </li>
        <li><a href="#"><i class="fas fa-database"></i> 持久化技术</a></li>
        <li><a href="#"><i class="fas fa-tools"></i> 构建工具</a></li>
        <li><a href="#"><i class="fas fa-cloud"></i> 微服务与云</a></li>
        <li><a href="#"><i class="fas fa-file"></i> 源码研究</a>
            <div class="dropdown">
                <a href="#">XXL-JOB</a>
            </div>
        </li>
        <li><a href="online-issues-index.html"><i class="fas fa-bug"></i> 线上问题记录</a></li>
    </ul>
</nav>
<div class="container">
    <main>
        <section class="section article-content">
            <h1>XXL-JOB原理及任务注册与心跳源码分析</h1>
            <div class="article-meta">发布于：2025-04-11</div>
            <p>XXL-JOB 是一个分布式任务调度平台，其核心原理基于任务调度中心与执行器的解耦设计，通过中心式调度和分布式执行的方式，实现任务的高效管理和执行。</p>
            <p>以下分析以2.2.0版本为基础</p>

            <h2 id="principle">原理</h2>
            <h3 id="main-modules">1. 主要模块</h3>
            <ol>
                <li><strong>xxl-job-core</strong>：核心模块，包含了 XXL-JOB 的核心功能和基础类库。</li>
                <li><strong>xxl-job-admin</strong>：调度中心，提供了 Web 界面用于任务的管理和调度，支持任务的 CRUD 操作、动态修改任务状态等功能。</li>
                <li><strong>xxl-job-executor-samples</strong>：执行器示例模块，包含了不同框架的执行器示例，如无框架示例、Spring Boot 示例等。</li>
            </ol>

            <h3 id="architecture-design">2. 架构设计</h3>
            <p>XXL-JOB 的架构主要由两部分组成：<strong>调度中心</strong>和<strong>执行器</strong>。</p>
            <ul>
                <li><strong>调度中心</strong>：负责管理任务的调度信息，按照配置的触发策略（如 Cron 表达式）发出调度请求。调度中心不直接执行业务逻辑，而是通过远程调用的方式通知执行器执行任务。</li>
                <li><strong>执行器</strong>：负责接收调度中心的调度请求，并执行具体的任务逻辑。执行器可以部署在多个节点上，支持集群部署，从而保证任务执行的高可用性。</li>
            </ul>

            <h3 id="task-registration-heartbeat">3. 任务注册与心跳机制</h3>
            <ol>
                <li><strong>任务注册</strong>
                    <ol>
                        <li>执行器启动时，会通过 <code>@XxlJob</code> 注解扫描项目中的任务方法，并将这些任务注册到调度中心。</li>
                        <li>注册信息包括执行器的名称（<code>appname</code>）、IP 地址和端口号等。</li>
                        <li>调度中心接收到注册信息后，会将其存储到数据库中，并用于后续的任务调度。</li>
                    </ol>
                </li>
                <li><strong>心跳机制</strong>
                    <ol>
                        <li>执行器会定期（默认每 30 秒）向调度中心发送心跳信号。</li>
                        <li>心跳信号用于告知调度中心执行器的当前状态（如是否在线）。如果调度中心在一定时间内（默认 90 秒）未收到执行器的心跳信号，则认为该执行器已下线。</li>
                        <li>心跳机制确保了调度中心能够实时了解执行器的状态，并在执行器下线时及时重新分配任务。</li>
                    </ol>
                </li>
            </ol>

            <h3 id="task-scheduling-process">4. 任务调度流程</h3>
            <ol>
                <li><strong>调度中心触发任务</strong>：根据任务的触发策略（如 Cron 表达式），调度中心在指定的时间点向执行器发送任务执行请求。</li>
                <li><strong>执行器接收并执行任务</strong>：执行器接收到任务请求后，根据任务的 <code>JobHandler</code> 名称找到对应的任务方法，并执行该方法。</li>
                <li><strong>任务日志记录</strong>：任务执行过程中，执行器会通过 <code>XxlJobLogger</code> 打印日志，调度中心可以通过任务日志查看任务的执行情况。</li>
            </ol>

            <h3 id="dynamic-task-management">5. 任务的动态管理</h3>
            <p>XXL-JOB 支持通过 Web 页面对任务进行动态管理，包括：</p>
            <ul>
                <li>动态修改任务状态（如启动、停止）。</li>
                <li>动态更新任务的触发策略（如修改 Cron 表达式）。</li>
                <li>查看任务的执行日志。</li>
            </ul>

            <h3 id="high-availability-scalability">6. 高可用性与扩展性</h3>
            <ul>
                <li><strong>调度中心 HA</strong>：调度中心支持集群部署，通过数据库存储任务信息，确保调度中心的高可用性。</li>
                <li><strong>执行器 HA</strong>：执行器支持集群部署，任务可以在多个执行器节点上分布执行，确保任务执行的高可用性。</li>
                <li><strong>弹性扩容缩容</strong>：当有新的执行器节点上线或下线时，调度中心会自动重新分配任务。</li>
            </ul>

            <h3 id="task-execution-modes">7. 任务执行模式</h3>
            <p>XXL-JOB 支持两种任务执行模式：</p>
            <ul>
                <li><strong>Bean 模式</strong>：任务以 Spring Bean 的形式开发，通过 <code>@XxlJob</code> 注解标记任务方法。</li>
                <li><strong>GLUE 模式</strong>：任务代码存储在数据库中，执行器动态加载任务代码并执行。</li>
            </ul>

            <h3 id="summary">8. 总结</h3>
            <p>XXL-JOB 通过中心式调度和分布式执行的设计，实现了任务的高效管理和执行。其任务注册和心跳机制确保了调度中心与执行器之间的通信可靠性，动态管理功能则提供了灵活的任务操作能力。</p>

            <h2 id="source-code-analysis">源码分析</h2>
            <h3 id="task-registration-heartbeat-source">1. 任务注册与心跳</h3>
            <h4 id="annotation-scanning-registration">a. 注解扫描与注册</h4>
            <p><code>@XxlJob</code> 注解的生效主要依赖于 <code>XxlJobSpringExecutor</code> 类，该类继承自 <code>XxlJobExecutor</code> 并实现了 <code>ApplicationContextAware</code>、<code>SmartInitializingSingleton</code> 和 <code>DisposableBean</code> 接口。</p>
            <p>在 <code>XxlJobSpringExecutor</code> 的 <code>afterSingletonsInstantiated</code> 方法中，会进行 <code>@XxlJob</code> 注解的扫描和注册：</p>
            <pre class="java"><code>@Override
public void afterSingletonsInstantiated() {
    // init JobHandler Repository (for method)
    initJobHandlerMethodRepository(applicationContext);

    // refresh GlueFactory
    GlueFactory.refreshInstance(1);

    // super start
    try {
        super.start();
    } catch (Exception e) {
        throw new RuntimeException(e);
    }
}
</code></pre>
            <p><code>initJobHandlerMethodRepository</code> 方法会扫描所有 Bean 中的方法，查找带有 <code>@XxlJob</code> 注解的方法，并将其注册到任务处理器仓库中：</p>
            <p>此处只是展示主要的代码，部分代码略过</p>
            <pre class="java"><code>private void initJobHandlerMethodRepository(ApplicationContext applicationContext) {
    if (applicationContext == null) {
        return;
    }
    // init job handler from method
    String[] beanDefinitionNames = applicationContext.getBeanNamesForType(Object.class, false, true);
    for (String beanDefinitionName : beanDefinitionNames) {
        // get bean
        Object bean = null;
        Lazy onBean = applicationContext.findAnnotationOnBean(beanDefinitionName, Lazy.class);
        if (onBean != null) {
            logger.debug(<span class="string">"xxl-job annotation scan, skip @Lazy Bean:{}"</span>, beanDefinitionName);
            continue;
        } else {
            bean = applicationContext.getBean(beanDefinitionName);
        }

        // 筛选带有 @XxlJob 注解的方法
        Map&lt;Method, XxlJob&gt; annotatedMethods = null;
        try {
            annotatedMethods = MethodIntrospector.selectMethods(bean.getClass(),
                new MethodIntrospector.MetadataLookup&lt;XxlJob&gt;() {
                    @Override
                    public XxlJob inspect(Method method) {
                        return AnnotatedElementUtils.findMergedAnnotation(method, XxlJob.class);
                    }
                });
        } catch (Throwable ex) {
            logger.error(<span class="string">"xxl-job method-jobhandler resolve error for bean[{}]"</span>, ex);
        }
        if (annotatedMethods == null || annotatedMethods.isEmpty()) {
            continue;
        }

        // 生成并注册方法任务处理器
        for (Map.Entry&lt;Method, XxlJob&gt; methodXxlJobEntry : annotatedMethods.entrySet()) {
            Method executeMethod = methodXxlJobEntry.getKey();
            XxlJob xxlJob = methodXxlJobEntry.getValue();
            Method initMethod = null;
            Method destroyMethod = null;

            if (xxlJob.init().trim().length() > 0) {
                try {
                    initMethod = bean.getClass().getDeclaredMethod(xxlJob.init());
                    initMethod.setAccessible(true);
                } catch (NoSuchMethodException e) {
                    throw new RuntimeException(<span class="string">"xxl-job method-jobhandler initMethod invalid, for[{}]"</span>, bean.getClass() + <span class="string">"#"</span> + method.getName());
                }
            }
            if (xxlJob.destroy().trim().length() > 0) {
                try {
                    destroyMethod = bean.getClass().getDeclaredMethod(xxlJob.destroy());
                    destroyMethod.setAccessible(true);
                } catch (NoSuchMethodException e) {
                    throw new RuntimeException(<span class="string">"xxl-job method-jobhandler destroyMethod invalid, for[{}]"</span>, bean.getClass() + <span class="string">"#"</span> + method.getName());
                }
            }

            // 注册任务处理器
            registJobHandler(name, new MethodJobHandler(bean, method, initMethod, destroyMethod));
        }
    }
}
</code></pre>

            <h4 id="task-initialization">b. 初始化任务</h4>
            <p><code>XxlJobSpringExecutor</code> 类的 <code>afterSingletonsInstantiated</code> 方法中调用了父类 <code>XxlJobExecutor</code> 类的 <code>start</code> 方法，来看看 <code>start()</code></p>
            <pre class="java"><code>public void start() throws Exception {
    // 初始化日志路径
    // 作用：为后续任务执行日志的记录提供基础，保证日志能够正确存储到指定路径。
    <span class="comment">XxlJobFileAppender.initLogPath(logPath);</span>

    // 初始化调度中心客户端，根据配置的调度中心地址 adminAddresses 和访问令牌 accessToken，初始化与调度中心通信的客户端列表 adminBizList。
    // 作用：建立执行器与调度中心之间的通信通道，以便执行器能够接收调度中心的调度任务和指令。
    <span class="comment">initAdminBizList(adminAddresses, accessToken);</span>

    // 启动日志清理线程
    // 作用：启动日志文件清理线程，保留指定天数的日志，通过创建新的守护线程，且每天执行一次
    <span class="comment">JobLogFileCleanThread.getInstance().start(logRetentionDays);</span>

    // 启动触发回调线程
    <span class="comment">TriggerCallbackThread.getInstance().start();</span>

    // 初始化嵌入式服务器，启动嵌入式服务器，绑定 IP 和端口，并注册服务。
    <span class="comment">initEmbedServer(address, ip, port, appname, accessToken);</span>
}
</code></pre>
            <p>重点看看下面几个方法：</p>
            <ol>
                <li><strong>回调线程</strong>
                    <p><code>TriggerCallbackThread.getInstance().start();</code></p>
                    <pre class="java"><code>public void start() {
    // valid
    if (XxlJobExecutor.getAdminBizList() == null) {
        logger.warn(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, executor callback config fail, adminAddresses is null."</span>);
        return;
    }

    // 创建一个名为 triggerCallbackThread 的线程，用于处理正常的回调逻辑。
    // 这个线程会一直运行直到 toStop 变量为 true
    triggerCallbackThread = new Thread(new Runnable() {
        @Override
        public void run() {
            // 正常回调
            while (!toStop) {
                try {
                    // 线程尝试从回调队列 callBackQueue 中取出回调参数 HandleCallbackParam。
                    HandleCallbackParam callback = getInstance().callBackQueue.take();
                    if (callback != null) {
                        // 尝试将队列中的所有回调参数取出并添加到一个列表 callbackParamList 中。
                        // 通过队列的 drainTo 方法
                        List&lt;HandleCallbackParam&gt; callbackParamList = new ArrayList&lt;HandleCallbackParam&gt;();
                        int drainToNum = getInstance().callBackQueue.drainTo(callbackParamList);
                        callbackParamList.add(callback);

                        // 如果发生错误会进行重试。
                        if (callbackParamList != null && callbackParamList.size() > 0) {
                            // doCallback 方法大致逻辑：尝试进行回调，回调成功则记录成功日志。回调失败或者异常，则将回调参数写入失败回调文件
                            doCallback(callbackParamList);
                        }
                    }
                } catch (Exception e) {
                    if (!toStop) {
                        logger.error(e.getMessage(), e);
                    }
                }
            }

            // 最后一次回调
            try {
                List&lt;HandleCallbackParam&gt; callbackParamList = new ArrayList&lt;HandleCallbackParam&gt;();
                int drainToNum = getInstance().callBackQueue.drainTo(callbackParamList);
                if (callbackParamList != null && callbackParamList.size() > 0) {
                    doCallback(callbackParamList);
                }
            } catch (Exception e) {
                if (!toStop) {
                    logger.error(e.getMessage(), e);
                }
            }
            logger.info(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, executor callback thread destroy."</span>);
        }
    });
    // 设置守护线程
    triggerCallbackThread.setDaemon(true);
    triggerCallbackThread.setName(<span class="string">"xxl-job, executor TriggerCallbackThread"</span>);
    triggerCallbackThread.start();

    // 用于处理回调失败的重试逻辑。这个线程同样会一直运行直到 toStop 变量为 true
    triggerRetryCallbackThread = new Thread(new Runnable() {
        @Override
        public void run() {
            while (!toStop) {
                try {
                    // retryFailCallbackFile 方法大致逻辑，从失败回调文件中拿出参数，调 doCallback 方法进行回调操作。
                    retryFailCallbackFile();
                } catch (Exception e) {
                    if (!toStop) {
                        logger.error(e.getMessage(), e);
                    }
                }
                try {
                    TimeUnit.SECONDS.sleep(RegistryConfig.BEAT_TIMEOUT);
                } catch (InterruptedException e) {
                    if (!toStop) {
                        logger.error(e.getMessage(), e);
                    }
                }
            }
            logger.info(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, executor retry callback thread destroy."</span>);
        }
    });
    triggerRetryCallbackThread.setDaemon(true);
    triggerRetryCallbackThread.start();
}
</code></pre>
                    <p><code>doCallback</code> 回调逻辑，调用 <code>com.xxl.job.core.biz.client.AdminBizClient#callback</code> 方法，向 xxl-job 控制台发送请求。实际上就是 xxl-job-admin 模块的 <code>com.xxl.job.admin.controller.JobApiController#api</code> 方法。</p>
                    <pre class="java"><code>public ReturnT&lt;String&gt; callback(List&lt;HandleCallbackParam&gt; callbackParamList) {
    return XxlJobRemotingUtil.postBody(this.addressUrl + <span class="string">"api/callback"</span>, this.accessToken, this.timeout, callbackParamList, String.class);
}
</code></pre>
                </li>
                <li><strong>任务注册</strong>
                    <p><code>initEmbedServer</code> 方法可以略过，主要看它所调用的另一个方法 <code>com.xxl.job.core.server.EmbedServer#start</code></p>
                    <p>主要功能是启动一个嵌入式 HTTP 服务器，监听特定端口，处理 HTTP 请求，并将请求分发给业务逻辑线程池处理。同时，它还包含了服务器启动和关闭的相关逻辑</p>
                    <pre class="java"><code>public void start(final String address, final int port, final String appname, final String accessToken) {
    executorBiz = new ExecutorBizImpl();
    thread = new Thread(new Runnable() {
        @Override
        public void run() {
            // bossGroup 用于接受连接
            EventLoopGroup bossGroup = new NioEventLoopGroup();
            // workerGroup 用于处理连接的流量。
            EventLoopGroup workerGroup = new NioEventLoopGroup();
            // 用于处理业务逻辑的线程池
            ThreadPoolExecutor bizThreadPool = new ThreadPoolExecutor(
                0,
                200,
                60L,
                TimeUnit.SECONDS,
                new LinkedBlockingQueue&lt;Runnable&gt;(2000),
                new ThreadFactory() {
                    @Override
                    public Thread newThread(Runnable r) {
                        return new Thread(r, <span class="string">"xxl-rpc, EmbedServer bizThreadPool-"</span> + r.hashCode());
                    }
                },
                new RejectedExecutionHandler() {
                    @Override
                    public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
                        throw new RuntimeException(<span class="string">"xxl-job, EmbedServer bizThreadPool is EXHAUSTED!"</span>);
                    }
                });

            try {
                // 使用 ServerBootstrap 来配置服务器
                ServerBootstrap bootstrap = new ServerBootstrap();
                // 设置 EventLoopGroup
                bootstrap.group(bossGroup, workerGroup)
                    .channel(NioServerSocketChannel.class)
                    .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() {
                        @Override
                        public void initChannel(SocketChannel channel) throws Exception {
                            channel.pipeline()
                                // IdleStateHandler：用于处理空闲连接，如果 30*3 秒（90 秒）内没有任何活动，则关闭连接。
                                .addLast(new IdleStateHandler(0, 0, 30 * 3, TimeUnit.SECONDS))
                                // HttpServerCodec：HTTP 请求和响应的编解码器。
                                .addLast(new HttpServerCodec())
                                // HttpObjectAggregator：将 HTTP 请求和响应聚合成完整的对象，最大大小为 5MB。
                                .addLast(new HttpObjectAggregator(5 * 1024 * 1024))
                                // EmbedHttpServerHandler：自定义的处理器，用于处理 HTTP 请求，传入了业务执行器、访问令牌和业务线程池。
                                .addLast(new EmbedHttpServerHandler(executorBiz, accessToken, bizThreadPool));
                        }
                    })
                    // 设置通道选项，例如启用 TCP 的 SO_KEEPALIVE 选项以保持连接活跃。
                    .childOption(ChannelOption.SO_KEEPALIVE, true);

                // 绑定服务器到指定的端口，并同步等待绑定操作完成
                ChannelFuture future = bootstrap.bind(port).sync();

                logger.info(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job remoting server start success, nettype = {}, port = {}"</span>, EmbedServer.class, port);

                // 启动注册中心
                startRegistry(appname, address);

                // 阻塞当前线程直到服务器关闭
                future.channel().closeFuture().sync();
            } catch (InterruptedException e) {
                if (e instanceof InterruptedException) {
                    logger.info(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job remoting server stop."</span>);
                } else {
                    logger.error(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job remoting server error."</span>, e);
                }
            } finally {
                // stop
                try {
                    workerGroup.shutdownGracefully();
                    bossGroup.shutdownGracefully();
                } catch (Exception e) {
                    logger.error(e.getMessage(), e);
                }
            }
        }
    });
    thread.setDaemon(true); // daemon, service jvm, user thread leave >>> daemon leave >>> jvm leave
    thread.start();
}
</code></pre>
                    <p><code>startRegistry(appname, address);</code> 方法实际上调用的是 xxl-job-admin 模块的 <code>com.xxl.job.admin.controller.JobApiController#api</code> 方法。</p>
                    <ol>
                        <li><strong>调度中心接受注册信息</strong>
                            <pre class="java"><code>@Override
public ReturnT&lt;String&gt; registry(RegistryParam registryParam) {
    // valid
    if (!StringUtils.hasText(registryParam.getRegistryGroup())
            || !StringUtils.hasText(registryParam.getRegistryKey())
            || !StringUtils.hasText(registryParam.getRegistryValue())) {
        return new ReturnT&lt;String&gt;(ReturnT.FAIL_CODE, <span class="string">"Illegal Argument."</span>);
    }

    // 更新数小于0，则插入
    int ret = xxlJobRegistryDao.registryUpdate(registryParam.getRegistryGroup(), registryParam.getRegistryKey(), registryParam.getRegistryValue(), new Date());
    if (ret < 1) {
        xxlJobRegistryDao.registrySave(registryParam.getRegistryGroup(), registryParam.getRegistryKey(), registryParam.getRegistryValue(), new Date());

        // 这里是一个空方法，什么都没做，可能是版本的原因
        freshGroupRegistryInfo(registryParam);
    }
    return ReturnT.SUCCESS;
}
</code></pre>
                        </li>
                    </ol>
                </li>
                <li><strong>心跳机制</strong>
                    <p>再次看一看任务注册方法</p>
                    <pre class="java"><code>public void startRegistry(final String appname, final String address) {
    // start registry
    ExecutorRegistryThread.getInstance().start(appname, address);
}
</code></pre>
                    <p>主要负责注册和注销执行器（Executor）到 XXL-JOB 调度中心。</p>
                    <p>当 <code>toStop</code> 不为 <code>true</code> 的时候，每隔 30 秒定时往 xxl-job 调度中心进行注册。xxl-job 接受注册的方法是直接更新，当更新数小于 0 时才是新增，这样有效的避免了大量的查询。</p>
                    <pre class="java"><code>public void start(final String appname, final String address) {
    // valid
    if (appname == null || appname.trim().length() == 0) {
        logger.warn(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, executor registry config fail, appname is null."</span>);
        return;
    }
    if (XxlJobExecutor.getAdminBizList() == null) {
        logger.warn(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, executor registry config fail, adminAddresses is null."</span>);
        return;
    }

    registryThread = new Thread(new Runnable() {
        @Override
        public void run() {
            // registry
            while (!toStop) {
                try {
                    RegistryParam registryParam = new RegistryParam(RegistryConfig.RegistType.EXECUTOR.name(), appname, address);
                    // 遍历管理员业务列表 XxlJobExecutor.getAdminBizList()，对每个 AdminBiz 实例尝试执行注册操作。
                    // 如果配置了多个 ip，则会往多个调度中心发送注册信息
                    for (AdminBiz adminBiz : XxlJobExecutor.getAdminBizList()) {
                        try {
                            ReturnT&lt;String&gt; registryResult = adminBiz.registry(registryParam);
                            if (registryResult != null && ReturnT.SUCCESS_CODE == registryResult.getCode()) {
                                registryResult = ReturnT.SUCCESS;
                                logger.debug(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job registry success, registryParam:{}, registryResult:{}"</span>, new Object[]{registryParam, registryResult});
                                break;
                            } else {
                                logger.info(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job registry fail, registryParam:{}, registryResult:{}"</span>, new Object[]{registryParam, registryResult});
                            }
                        } catch (Exception e) {
                            logger.info(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job registry error, registryParam:{}"</span>, registryParam, e);
                        }
                    }
                } catch (Exception e) {
                    if (!toStop) {
                        logger.error(e.getMessage(), e);
                    }
                }

                try {
                    if (!toStop) {
                        TimeUnit.SECONDS.sleep(RegistryConfig.BEAT_TIMEOUT);
                    }
                } catch (InterruptedException e) {
                    if (!toStop) {
                        logger.warn(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, executor registry thread interrupted, error msg:{}"</span>, e.getMessage());
                    }
                }
            }

            // registry remove
            try {
                RegistryParam registryParam = new RegistryParam(RegistryConfig.RegistType.EXECUTOR.name(), appname, address);
                for (AdminBiz adminBiz : XxlJobExecutor.getAdminBizList()) {
                    try {
                        ReturnT&lt;String&gt; registryResult = adminBiz.registryRemove(registryParam);
                        if (registryResult != null && ReturnT.SUCCESS_CODE == registryResult.getCode()) {
                            registryResult = ReturnT.SUCCESS;
                            logger.info(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job registry-remove success, registryParam:{}, registryResult:{}"</span>, new Object[]{registryParam, registryResult});
                            break;
                        } else {
                            logger.info(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job registry-remove fail, registryParam:{}, registryResult:{}"</span>, new Object[]{registryParam, registryResult});
                        }
                    } catch (Exception e) {
                        if (!toStop) {
                            logger.info(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job registry-remove error, registryParam:{}"</span>, registryParam, e);
                        }
                    }
                }
            } catch (Exception e) {
                if (!toStop) {
                    logger.error(e.getMessage(), e);
                }
            }
            logger.info(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, executor registry thread destroy."</span>);
        }
    });
    registryThread.setDaemon(true);
    registryThread.setName(<span class="string">"xxl-job, executor ExecutorRegistryThread"</span>);
    registryThread.start();
}
</code></pre>
                    <ol>
                        <li><strong>调度中心的心跳管理</strong>
                            <p>调度中心通过 <code>com.xxl.job.admin.core.thread.JobRegistryMonitorHelper</code> 类，周期性的对心跳进行检测。</p>
                            <pre class="java"><code>public void start() {
    registryThread = new Thread(new Runnable() {
        @Override
        public void run() {
            while (!toStop) {
                try {
                    // 获取地址类型为 0 的任务组列表（自动注册任务组列表）
                    List&lt;XxlJobGroup&gt; groupList = XxlJobAdminConfig.getAdminConfig().getXxlJobGroupDao().findByAddressType(0);
                    if (groupList != null && !groupList.isEmpty()) {
                        // 查找超时 3*30 秒未更新的注册信息，并移除这些死亡的地址。
                        List&lt;Integer&gt; ids = XxlJobAdminConfig.getAdminConfig().getXxlJobRegistryDao().findDead(RegistryConfig.DEAD_TIMEOUT, new Date());
                        if (ids != null && ids.size() > 0) {
                            XxlJobAdminConfig.getAdminConfig().getXxlJobRegistryDao().removeDead(ids);
                        }

                        // 创建一个映射表 appAddressMap 来存储每个应用名称对应的注册地址列表。
                        HashMap&lt;String, List&lt;String&gt;&gt; appAddressMap = new HashMap&lt;String, List&lt;String&gt;&gt;();
                        // 查找所有未超时的注册信息，并更新映射表。
                        List&lt;XxlJobRegistry&gt; list = XxlJobAdminConfig.getAdminConfig().getXxlJobRegistryDao().findAll(RegistryConfig.DEAD_TIMEOUT, new Date());
                        if (list != null) {
                            for (XxlJobRegistry item : list) {
                                if (RegistryConfig.RegistType.EXECUTOR.name().equals(item.getRegistryGroup())) {
                                    String appname = item.getRegistryKey();
                                    List&lt;String&gt; registryList = appAddressMap.get(appname);
                                    if (registryList == null) {
                                        registryList = new ArrayList&lt;String&gt;();
                                    }

                                    if (!registryList.contains(item.getRegistryValue())) {
                                        registryList.add(item.getRegistryValue());
                                    }
                                    appAddressMap.put(appname, registryList);
                                }
                            }
                        }

                        // 更新任务组地址列表
                        for (XxlJobGroup group : groupList) {
                            List&lt;String&gt; registryList = appAddressMap.get(group.getAppname());
                            String addressListStr = null;
                            if (registryList != null && !registryList.isEmpty()) {
                                Collections.sort(registryList);
                                addressListStr = "";
                                for (String item : registryList) {
                                    addressListStr += item + ",";
                                }
                                addressListStr = addressListStr.substring(0, addressListStr.length() - 1);
                            }
                            group.setAddressList(addressListStr);
                            XxlJobAdminConfig.getAdminConfig().getXxlJobGroupDao().update(group);
                        }
                    }
                } catch (Exception e) {
                    if (!toStop) {
                        logger.error(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, job registry monitor thread error:{}"</span>, e);
                    }
                }
                try {
                    TimeUnit.SECONDS.sleep(RegistryConfig.BEAT_TIMEOUT);
                } catch (InterruptedException e) {
                    if (!toStop) {
                        logger.error(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, job registry monitor thread error:{}"</span>, e);
                    }
                }
            }
            logger.info(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, job registry monitor thread stop"</span>);
        }
    });
    registryThread.setDaemon(true);
    registryThread.setName(<span class="string">"xxl-job, admin JobRegistryMonitorHelper"</span>);
    registryThread.start();
}
</code></pre>
                        </li>
                    </ol>
                </li>
            </ol>
            <p>xxl-job 运用了大量的线程、守护线程和 netty</p>

            <h2 id="xxl-job-task-scheduling-source">XXL-JOB 任务调度源码分析</h2>
            <p>详情见：<a href="20250411171835.html" target="_blank">XXL-JOB 任务调度源码分析</a> </p>

            <div class="article-tags">
                <a href="#">XXL-JOB</a>
                <a href="#">任务调度</a>
                <a href="#">源码分析</a>
                <a href="#">分布式系统</a>
            </div>
        </section>
    </main>
    <aside>
        <section class="section toc">
            <h3>文章目录</h3>
            <ul>
                <li><a href="#principle">原理</a>
                    <ul>
                        <li><a href="#main-modules">1. 主要模块</a></li>
                        <li><a href="#architecture-design">2. 架构设计</a></li>
                        <li><a href="#task-registration-heartbeat">3. 任务注册与心跳机制</a></li>
                        <li><a href="#task-scheduling-process">4. 任务调度流程</a></li>
                        <li><a href="#dynamic-task-management">5. 任务的动态管理</a></li>
                        <li><a href="#high-availability-scalability">6. 高可用性与扩展性</a></li>
                        <li><a href="#task-execution-modes">7. 任务执行模式</a></li>
                        <li><a href="#summary">8. 总结</a></li>
                    </ul>
                </li>
                <li><a href="#source-code-analysis">源码分析</a>
                    <ul>
                        <li><a href="#task-registration-heartbeat-source">1. 任务注册与心跳</a>
                            <ul>
                                <li><a href="#annotation-scanning-registration">a. 注解扫描与注册</a></li>
                                <li><a href="#task-initialization">b. 初始化任务</a></li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li><a href="#xxl-job-task-scheduling-source">XXL-JOB 任务调度源码分析</a></li>
            </ul>
        </section>
        <section class="section tags">
            <h3>文章标签</h3>
            <div>
                <a href="#" class="article-tags">XXL-JOB</a>
                <a href="#" class="article-tags">任务调度</a>
                <a href="#" class="article-tags">源码分析</a>
                <a href="#" class="article-tags">分布式系统</a>
            </div>
        </section>
        <section class="section hot-posts">
            <h3>热门文章</h3>
            <ul>
                <li><a href="#">Spring Boot 3.3实战</a></li>
                <li><a href="#">Hibernate性能优化</a></li>
                <li><a href="#">Java并发编程入门</a></li>
            </ul>
        </section>
    </aside>
</div>
<footer>
    <div class="social">
        <a href="#" aria-label="WeChat"><i class="fab fa-weixin"></i></a>
        <a href="#" aria-label="Weibo"><i class="fab fa-weibo"></i></a>
        <a href="#" aria-label="QQ"><i class="fab fa-qq"></i></a>
    </div>
    <p>联系方式：<a href="/cdn-cgi/l/email-protection">[email&nbsp;protected]</a> | <a href="#">服务条款</a></p>
    <p>© 2025 Java技术站 版权所有</p>
</footer>
</body>
</html>
